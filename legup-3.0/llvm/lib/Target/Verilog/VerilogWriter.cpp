//===-- VerilogWriter.cpp -----------------------------------------*- C++ -*-===//
//
// This file is distributed under the LegUp license. See LICENSE for details.
//
//===----------------------------------------------------------------------===//
//
// Implements VerilogWriter class
//
//===----------------------------------------------------------------------===//

#include "VerilogWriter.h"
#include "Allocation.h"
#include "LegupPass.h"
#include "GenerateRTL.h"
#include "utils.h"
#include "Ram.h"
#include <vector>
#include <iostream>
#include <fstream>

using namespace llvm;
using namespace legup;

//extern std::set<Function*> AcceleratedFcts;
namespace legup {

void VerilogWriter::print() {
    Out << getFileHeader();

	if (LEGUP_CONFIG->numAccelerators() > 0) {
		//print Top Module for each accelerated function
        for (std::set<const Function*>::const_iterator
                it=AcceleratedFcts.begin(); it != AcceleratedFcts.end(); ++it)
        {
				printTop(*it);
		}
	}
	else {
		printTop(NULL);
	}

    printMemoryController();

    for (Allocation::const_rtl_iterator i = alloc->rtl_begin(), e =
            alloc->rtl_end(); i != e; ++i) {
        printRTL(*i);
    }

    // TODO: don't print if we don't have rams
    //if (rams.empty()) return;
    printRAMModule();

    if (LEGUP_CONFIG->getParameterInt("MULTIPUMPING")) {
        printPLLModule();
        printClkFollowerModule();
        printMultipumpModule();
    }
    printDE2();
    printDE4();
    printHex();

	//don't print test bench for hybrid flow
	if (LEGUP_CONFIG->numAccelerators() == 0) {
	    printVerilogTestbench();
	}
}



void VerilogWriter::printBlankDefaultCase(std::string indent) {
    Out << indent << "default:" << "\n";
    Out << indent << "begin" << "\n";
    Out << indent << "\t// quartus issues a warning if we have no default case"
        << "\n";
    Out << indent << "end" << "\n";
}

void VerilogWriter::printPLLModule() {

    Out <<
    "// megafunction wizard: %ALTPLL%\n" <<
    "// GENERATION: STANDARD\n" <<
    "// VERSION: WM1.0\n" <<
    "// MODULE: altpll \n" <<
    "\n" <<
    "// ============================================================\n" <<
    "// File Name: pll.v\n" <<
    "// Megafunction Name(s):\n" <<
    "// 			altpll\n" <<
    "//\n" <<
    "// Simulation Library Files(s):\n" <<
    "// 			altera_mf\n" <<
    "// ============================================================\n" <<
    "// ************************************************************\n" <<
    "// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!\n" <<
    "//\n" <<
    "// 10.1 Build 197 01/19/2011 SP 1 SJ Full Version\n" <<
    "// ************************************************************\n" <<
    "\n" <<
    "\n" <<
    "//Copyright (C) 1991-2011 Altera Corporation\n" <<
    "//Your use of Altera Corporation's design tools, logic functions \n" <<
    "//and other software and tools, and its AMPP partner logic \n" <<
    "//functions, and any output files from any of the foregoing \n" <<
    "//(including device programming or simulation files), and any \n" <<
    "//associated documentation or information are expressly subject \n" <<
    "//to the terms and conditions of the Altera Program License \n" <<
    "//Subscription Agreement, Altera MegaCore Function License \n" <<
    "//Agreement, or other applicable license agreement, including, \n" <<
    "//without limitation, that your use is for the sole purpose of \n" <<
    "//programming logic devices manufactured by Altera and sold by \n" <<
    "//Altera or its authorized distributors.  Please refer to the \n" <<
    "//applicable agreement for further details.\n" <<
    "\n" <<
    "\n" <<
    "// synopsys translate_off\n" <<
    "`timescale 1 ns / 1 ns\n" <<
    "// synopsys translate_on\n" <<
    "module pll (\n" <<
    "inclk0,\n" <<
    "c0,\n" <<
    "c1);\n" <<
    "\n" <<
    "input	  inclk0;\n" <<
    "output	  c0;\n" <<
    "output	  c1;\n" <<
    "\n" <<
    "wire [5:0] sub_wire0;\n" <<
    "wire [0:0] sub_wire5 = 1'h0;\n" <<
    "wire [1:1] sub_wire2 = sub_wire0[1:1];\n" <<
    "wire [0:0] sub_wire1 = sub_wire0[0:0];\n" <<
    "wire  c0 = sub_wire1;\n" <<
    "wire  c1 = sub_wire2;\n" <<
    "wire  sub_wire3 = inclk0;\n" <<
    "wire [1:0] sub_wire4 = {sub_wire5, sub_wire3};\n" <<
    "\n" <<
    "altpll	altpll_component (\n" <<
    ".inclk (sub_wire4),\n" <<
    ".clk (sub_wire0),\n" <<
    ".activeclock (),\n" <<
    ".areset (1'b0),\n" <<
    ".clkbad (),\n" <<
    ".clkena ({6{1'b1}}),\n" <<
    ".clkloss (),\n" <<
    ".clkswitch (1'b0),\n" <<
    ".configupdate (1'b0),\n" <<
    ".enable0 (),\n" <<
    ".enable1 (),\n" <<
    ".extclk (),\n" <<
    ".extclkena ({4{1'b1}}),\n" <<
    ".fbin (1'b1),\n" <<
    ".fbmimicbidir (),\n" <<
    ".fbout (),\n" <<
    ".fref (),\n" <<
    ".icdrclk (),\n" <<
    ".locked (),\n" <<
    ".pfdena (1'b1),\n" <<
    ".phasecounterselect ({4{1'b1}}),\n" <<
    ".phasedone (),\n" <<
    ".phasestep (1'b1),\n" <<
    ".phaseupdown (1'b1),\n" <<
    ".pllena (1'b1),\n" <<
    ".scanaclr (1'b0),\n" <<
    ".scanclk (1'b0),\n" <<
    ".scanclkena (1'b1),\n" <<
    ".scandata (1'b0),\n" <<
    ".scandataout (),\n" <<
    ".scandone (),\n" <<
    ".scanread (1'b0),\n" <<
    ".scanwrite (1'b0),\n" <<
    ".sclkout0 (),\n" <<
    ".sclkout1 (),\n" <<
    ".vcooverrange (),\n" <<
    ".vcounderrange ());\n" <<
    "defparam\n" <<
    "altpll_component.clk0_divide_by = 1,\n" <<
    "altpll_component.clk0_duty_cycle = 50,\n" <<
    "altpll_component.clk0_multiply_by = 1,\n" <<
    "altpll_component.clk0_phase_shift = \"0\",\n" <<
    "altpll_component.clk1_divide_by = 1,\n" <<
    "altpll_component.clk1_duty_cycle = 50,\n" <<
    "altpll_component.clk1_multiply_by = 2,\n" <<
    "altpll_component.clk1_phase_shift = \"0\",\n" <<
    "altpll_component.compensate_clock = \"CLK0\",\n" <<
    "altpll_component.inclk0_input_frequency = 20000,\n" <<
    "altpll_component.intended_device_family = \"Cyclone II\",\n" <<
    "altpll_component.lpm_hint = \"CBX_MODULE_PREFIX=pll\",\n" <<
    "altpll_component.lpm_type = \"altpll\",\n" <<
    "altpll_component.operation_mode = \"NORMAL\",\n" <<
    "altpll_component.port_activeclock = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_areset = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_clkbad0 = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_clkbad1 = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_clkloss = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_clkswitch = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_configupdate = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_fbin = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_inclk0 = \"PORT_USED\",\n" <<
    "altpll_component.port_inclk1 = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_locked = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_pfdena = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_phasecounterselect = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_phasedone = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_phasestep = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_phaseupdown = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_pllena = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_scanaclr = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_scanclk = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_scanclkena = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_scandata = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_scandataout = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_scandone = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_scanread = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_scanwrite = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_clk0 = \"PORT_USED\",\n" <<
    "altpll_component.port_clk1 = \"PORT_USED\",\n" <<
    "altpll_component.port_clk2 = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_clk3 = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_clk4 = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_clk5 = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_clkena0 = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_clkena1 = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_clkena2 = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_clkena3 = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_clkena4 = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_clkena5 = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_extclk0 = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_extclk1 = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_extclk2 = \"PORT_UNUSED\",\n" <<
    "altpll_component.port_extclk3 = \"PORT_UNUSED\";\n" <<
    "\n" <<
    "\n" <<
    "endmodule\n" <<
    "\n" <<
    "// ============================================================\n" <<
    "// CNX file retrieval info\n" <<
    "// ============================================================\n" <<
    "// Retrieval info: PRIVATE: ACTIVECLK_CHECK STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: BANDWIDTH STRING \"1.000\"\n" <<
    "// Retrieval info: PRIVATE: BANDWIDTH_FEATURE_ENABLED STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: BANDWIDTH_FREQ_UNIT STRING \"MHz\"\n" <<
    "// Retrieval info: PRIVATE: BANDWIDTH_PRESET STRING \"Low\"\n" <<
    "// Retrieval info: PRIVATE: BANDWIDTH_USE_AUTO STRING \"1\"\n" <<
    "// Retrieval info: PRIVATE: BANDWIDTH_USE_CUSTOM STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: BANDWIDTH_USE_PRESET STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: CLKBAD_SWITCHOVER_CHECK STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: CLKLOSS_CHECK STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: CLKSWITCH_CHECK STRING \"1\"\n" <<
    "// Retrieval info: PRIVATE: CNX_NO_COMPENSATE_RADIO STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: CREATE_CLKBAD_CHECK STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: CREATE_INCLK1_CHECK STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: CUR_DEDICATED_CLK STRING \"c0\"\n" <<
    "// Retrieval info: PRIVATE: CUR_FBIN_CLK STRING \"c0\"\n" <<
    "// Retrieval info: PRIVATE: DEVICE_SPEED_GRADE STRING \"6\"\n" <<
    "// Retrieval info: PRIVATE: DIV_FACTOR0 NUMERIC \"1\"\n" <<
    "// Retrieval info: PRIVATE: DIV_FACTOR1 NUMERIC \"1\"\n" <<
    "// Retrieval info: PRIVATE: DUTY_CYCLE0 STRING \"50.00000000\"\n" <<
    "// Retrieval info: PRIVATE: DUTY_CYCLE1 STRING \"50.00000000\"\n" <<
    "// Retrieval info: PRIVATE: EFF_OUTPUT_FREQ_VALUE0 STRING \"100.000000\"\n" <<
    "// Retrieval info: PRIVATE: EFF_OUTPUT_FREQ_VALUE1 STRING \"200.000000\"\n" <<
    "// Retrieval info: PRIVATE: EXPLICIT_SWITCHOVER_COUNTER STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: EXT_FEEDBACK_RADIO STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: GLOCKED_COUNTER_EDIT_CHANGED STRING \"1\"\n" <<
    "// Retrieval info: PRIVATE: GLOCKED_FEATURE_ENABLED STRING \"1\"\n" <<
    "// Retrieval info: PRIVATE: GLOCKED_MODE_CHECK STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: GLOCK_COUNTER_EDIT NUMERIC \"1048575\"\n" <<
    "// Retrieval info: PRIVATE: HAS_MANUAL_SWITCHOVER STRING \"1\"\n" <<
    "// Retrieval info: PRIVATE: INCLK0_FREQ_EDIT STRING \"50.000\"\n" <<
    "// Retrieval info: PRIVATE: INCLK0_FREQ_UNIT_COMBO STRING \"MHz\"\n" <<
    "// Retrieval info: PRIVATE: INCLK1_FREQ_EDIT STRING \"100.000\"\n" <<
    "// Retrieval info: PRIVATE: INCLK1_FREQ_EDIT_CHANGED STRING \"1\"\n" <<
    "// Retrieval info: PRIVATE: INCLK1_FREQ_UNIT_CHANGED STRING \"1\"\n" <<
    "// Retrieval info: PRIVATE: INCLK1_FREQ_UNIT_COMBO STRING \"MHz\"\n" <<
    "// Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING \"Cyclone II\"\n" <<
    "// Retrieval info: PRIVATE: INT_FEEDBACK__MODE_RADIO STRING \"1\"\n" <<
    "// Retrieval info: PRIVATE: LOCKED_OUTPUT_CHECK STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: LONG_SCAN_RADIO STRING \"1\"\n" <<
    "// Retrieval info: PRIVATE: LVDS_MODE_DATA_RATE STRING \"Not Available\"\n" <<
    "// Retrieval info: PRIVATE: LVDS_MODE_DATA_RATE_DIRTY NUMERIC \"0\"\n" <<
    "// Retrieval info: PRIVATE: LVDS_PHASE_SHIFT_UNIT0 STRING \"deg\"\n" <<
    "// Retrieval info: PRIVATE: LVDS_PHASE_SHIFT_UNIT1 STRING \"deg\"\n" <<
    "// Retrieval info: PRIVATE: MIG_DEVICE_SPEED_GRADE STRING \"Any\"\n" <<
    "// Retrieval info: PRIVATE: MIRROR_CLK0 STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: MIRROR_CLK1 STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: MULT_FACTOR0 NUMERIC \"4\"\n" <<
    "// Retrieval info: PRIVATE: MULT_FACTOR1 NUMERIC \"1\"\n" <<
    "// Retrieval info: PRIVATE: NORMAL_MODE_RADIO STRING \"1\"\n" <<
    "// Retrieval info: PRIVATE: OUTPUT_FREQ0 STRING \"100.00000000\"\n" <<
    "// Retrieval info: PRIVATE: OUTPUT_FREQ1 STRING \"200.00000000\"\n" <<
    "// Retrieval info: PRIVATE: OUTPUT_FREQ_MODE0 STRING \"1\"\n" <<
    "// Retrieval info: PRIVATE: OUTPUT_FREQ_MODE1 STRING \"1\"\n" <<
    "// Retrieval info: PRIVATE: OUTPUT_FREQ_UNIT0 STRING \"MHz\"\n" <<
    "// Retrieval info: PRIVATE: OUTPUT_FREQ_UNIT1 STRING \"MHz\"\n" <<
    "// Retrieval info: PRIVATE: PHASE_RECONFIG_FEATURE_ENABLED STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: PHASE_RECONFIG_INPUTS_CHECK STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: PHASE_SHIFT0 STRING \"0.00000000\"\n" <<
    "// Retrieval info: PRIVATE: PHASE_SHIFT1 STRING \"0.00000000\"\n" <<
    "// Retrieval info: PRIVATE: PHASE_SHIFT_STEP_ENABLED_CHECK STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: PHASE_SHIFT_UNIT0 STRING \"deg\"\n" <<
    "// Retrieval info: PRIVATE: PHASE_SHIFT_UNIT1 STRING \"deg\"\n" <<
    "// Retrieval info: PRIVATE: PLL_ADVANCED_PARAM_CHECK STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: PLL_ARESET_CHECK STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: PLL_AUTOPLL_CHECK NUMERIC \"1\"\n" <<
    "// Retrieval info: PRIVATE: PLL_ENA_CHECK STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: PLL_ENHPLL_CHECK NUMERIC \"0\"\n" <<
    "// Retrieval info: PRIVATE: PLL_FASTPLL_CHECK NUMERIC \"0\"\n" <<
    "// Retrieval info: PRIVATE: PLL_FBMIMIC_CHECK STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: PLL_LVDS_PLL_CHECK NUMERIC \"0\"\n" <<
    "// Retrieval info: PRIVATE: PLL_PFDENA_CHECK STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: PLL_TARGET_HARCOPY_CHECK NUMERIC \"0\"\n" <<
    "// Retrieval info: PRIVATE: PRIMARY_CLK_COMBO STRING \"inclk0\"\n" <<
    "// Retrieval info: PRIVATE: RECONFIG_FILE STRING \"pll.mif\"\n" <<
    "// Retrieval info: PRIVATE: SACN_INPUTS_CHECK STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: SCAN_FEATURE_ENABLED STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: SELF_RESET_LOCK_LOSS STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: SHORT_SCAN_RADIO STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: SPREAD_FEATURE_ENABLED STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: SPREAD_FREQ STRING \"50.000\"\n" <<
    "// Retrieval info: PRIVATE: SPREAD_FREQ_UNIT STRING \"KHz\"\n" <<
    "// Retrieval info: PRIVATE: SPREAD_PERCENT STRING \"0.500\"\n" <<
    "// Retrieval info: PRIVATE: SPREAD_USE STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: SRC_SYNCH_COMP_RADIO STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: STICKY_CLK0 STRING \"1\"\n" <<
    "// Retrieval info: PRIVATE: STICKY_CLK1 STRING \"1\"\n" <<
    "// Retrieval info: PRIVATE: SWITCHOVER_COUNT_EDIT NUMERIC \"1\"\n" <<
    "// Retrieval info: PRIVATE: SWITCHOVER_FEATURE_ENABLED STRING \"1\"\n" <<
    "// Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: USE_CLK0 STRING \"1\"\n" <<
    "// Retrieval info: PRIVATE: USE_CLK1 STRING \"1\"\n" <<
    "// Retrieval info: PRIVATE: USE_CLKENA0 STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: USE_CLKENA1 STRING \"0\"\n" <<
    "// Retrieval info: PRIVATE: USE_MIL_SPEED_GRADE NUMERIC \"0\"\n" <<
    "// Retrieval info: PRIVATE: ZERO_DELAY_RADIO STRING \"0\"\n" <<
    "// Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all\n" <<
    "// Retrieval info: CONSTANT: CLK0_DIVIDE_BY NUMERIC \"1\"\n" <<
    "// Retrieval info: CONSTANT: CLK0_DUTY_CYCLE NUMERIC \"50\"\n" <<
    "// Retrieval info: CONSTANT: CLK0_MULTIPLY_BY NUMERIC \"2\"\n" <<
    "// Retrieval info: CONSTANT: CLK0_PHASE_SHIFT STRING \"0\"\n" <<
    "// Retrieval info: CONSTANT: CLK1_DIVIDE_BY NUMERIC \"1\"\n" <<
    "// Retrieval info: CONSTANT: CLK1_DUTY_CYCLE NUMERIC \"50\"\n" <<
    "// Retrieval info: CONSTANT: CLK1_MULTIPLY_BY NUMERIC \"4\"\n" <<
    "// Retrieval info: CONSTANT: CLK1_PHASE_SHIFT STRING \"0\"\n" <<
    "// Retrieval info: CONSTANT: COMPENSATE_CLOCK STRING \"CLK0\"\n" <<
    "// Retrieval info: CONSTANT: INCLK0_INPUT_FREQUENCY NUMERIC \"20000\"\n" <<
    "// Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING \"Cyclone II\"\n" <<
    "// Retrieval info: CONSTANT: LPM_TYPE STRING \"altpll\"\n" <<
    "// Retrieval info: CONSTANT: OPERATION_MODE STRING \"NORMAL\"\n" <<
    "// Retrieval info: CONSTANT: PORT_ACTIVECLOCK STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_ARESET STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_CLKBAD0 STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_CLKBAD1 STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_CLKLOSS STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_CLKSWITCH STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_CONFIGUPDATE STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_FBIN STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_INCLK0 STRING \"PORT_USED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_INCLK1 STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_LOCKED STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_PFDENA STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_PHASECOUNTERSELECT STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_PHASEDONE STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_PHASESTEP STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_PHASEUPDOWN STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_PLLENA STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_SCANACLR STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_SCANCLK STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_SCANCLKENA STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_SCANDATA STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_SCANDATAOUT STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_SCANDONE STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_SCANREAD STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_SCANWRITE STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_clk0 STRING \"PORT_USED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_clk1 STRING \"PORT_USED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_clk2 STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_clk3 STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_clk4 STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_clk5 STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_clkena0 STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_clkena1 STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_clkena2 STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_clkena3 STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_clkena4 STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_clkena5 STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_extclk0 STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_extclk1 STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_extclk2 STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: CONSTANT: PORT_extclk3 STRING \"PORT_UNUSED\"\n" <<
    "// Retrieval info: USED_PORT: @clk 0 0 6 0 OUTPUT_CLK_EXT VCC \"@clk[5..0]\"\n" <<
    "// Retrieval info: USED_PORT: @extclk 0 0 4 0 OUTPUT_CLK_EXT VCC \"@extclk[3..0]\"\n" <<
    "// Retrieval info: USED_PORT: c0 0 0 0 0 OUTPUT_CLK_EXT VCC \"c0\"\n" <<
    "// Retrieval info: USED_PORT: c1 0 0 0 0 OUTPUT_CLK_EXT VCC \"c1\"\n" <<
    "// Retrieval info: USED_PORT: inclk0 0 0 0 0 INPUT_CLK_EXT GND \"inclk0\"\n" <<
    "// Retrieval info: CONNECT: @inclk 0 0 1 1 GND 0 0 0 0\n" <<
    "// Retrieval info: CONNECT: @inclk 0 0 1 0 inclk0 0 0 0 0\n" <<
    "// Retrieval info: CONNECT: c0 0 0 0 0 @clk 0 0 1 0\n" <<
    "// Retrieval info: CONNECT: c1 0 0 0 0 @clk 0 0 1 1\n" <<
    "// Retrieval info: GEN_FILE: TYPE_NORMAL pll.v TRUE\n" <<
    "// Retrieval info: GEN_FILE: TYPE_NORMAL pll.ppf TRUE\n" <<
    "// Retrieval info: GEN_FILE: TYPE_NORMAL pll.inc FALSE\n" <<
    "// Retrieval info: GEN_FILE: TYPE_NORMAL pll.cmp FALSE\n" <<
    "// Retrieval info: GEN_FILE: TYPE_NORMAL pll.bsf FALSE\n" <<
    "// Retrieval info: GEN_FILE: TYPE_NORMAL pll_inst.v TRUE\n" <<
    "// Retrieval info: GEN_FILE: TYPE_NORMAL pll_bb.v TRUE\n" <<
    "// Retrieval info: LIB_FILE: altera_mf\n" <<
    "// Retrieval info: CBX_MODULE_PREFIX: ON\n";
}

void VerilogWriter::printClkFollowerModule() {
    Out << "// see XAPP706\n" <<
    "// the clock follower avoids hold-time violations by generating a signal\n" <<
    "// from a register clocked by clk2x that follows clk1x\n" <<
    "module clock_follower (reset, clk1x, clk2x, clk1x_follower);\n" <<
        "input clk1x, clk2x, reset;\n" <<
        "output reg clk1x_follower;\n" <<
        "reg toggle, tog_1;\n" <<
    "\n" <<
        "always @(posedge clk1x or posedge reset)\n" <<
            "if (reset)\n" <<
                "toggle <= 0;\n" <<
            "else\n" <<
                "toggle <= ~toggle;\n" <<
    "\n" <<
        "always @(posedge clk2x)\n" <<
            "tog_1 <= toggle;\n" <<
    "\n" <<
        "always @(posedge clk2x)\n" <<
            "clk1x_follower <= ~(toggle ^ tog_1);\n" <<
    "\n" <<
    "endmodule\n";
}

void VerilogWriter::printMultipumpModule() {
    // multiplier is clocked at 2x the system clock
    unsigned stages =
        LEGUP_CONFIG->getParameterInt("MULTIPLIER_PIPELINE_STAGES");
    bool inputStage = (stages >= 3);
    if (inputStage) {
        // use one stage at the inputs
        stages--;
    }
    unsigned lpm_pipeline = 2 * stages;

    Out << "module multipump (\n" <<
    "clk,\n" <<
    "clk2x,\n" <<
    "clk1x_follower,\n" <<
    "inA,\n" <<
    "inB,\n" <<
    "outAxB,\n" <<
    "inC,\n" <<
    "inD,\n" <<
    "clken,\n" <<
    "outCxD);\n" <<
    "\n" <<
    "parameter size = 32;\n" <<
    "parameter sign = \"UNSIGNED\";\n" <<
    "\n" <<
    "input	   clk, clk2x, clk1x_follower, clken;\n" <<
    "input	   [size-1:0] inA, inB, inC, inD;\n" <<
    "output reg [size*2-1:0] outAxB, outCxD;\n";
    if (inputStage) {
        Out << "reg	   [size-1:0] inAreg, inBreg, inCreg, inDreg;\n" <<
        "always @(posedge clk) begin\n" <<
        "inAreg <= inA;\n" <<
        "inBreg <= inB;\n" <<
        "inCreg <= inC;\n" <<
        "inDreg <= inD;\n" <<
        "end\n" <<
        "\n" <<
        "\n";
    }
    Out << "\n" <<
    "wire [size*2-1:0] dsp_out;\n" <<
    "reg [size*2-1:0]  resultAB_reg, resultCD_reg;\n" <<
    "\n" <<
    "\n" <<
    "always @(*) begin\n" <<
    "outCxD = resultCD_reg;\n" <<
    "outAxB = resultAB_reg;\n" <<
    "end\n" <<
    "\n" <<
    "\n" <<
    "reg [size*2-1:0] dsp_out_fast;\n" <<
    "\n" <<
    "\n" <<
    "\n" <<
    "always @(posedge clk2x) begin\n" <<
    "dsp_out_fast <= dsp_out;\n" <<
    "end\n" <<
    "\n" <<
    "\n" <<
    "// the C x D result is ready\n" <<
    "always @(*) begin\n" <<
    "resultCD_reg <= dsp_out;\n" <<
    "end\n" <<
    "\n" <<
    "// the A x B result is ready\n" <<
    "always @(*) begin\n" <<
    "resultAB_reg <= dsp_out_fast;\n" <<
    "end\n" <<
    "\n" <<
    "\n" <<
    "\n" <<
    "wire      mux_sel;\n" <<
    "\n" <<
    "\n" <<
    "assign mux_sel = ~clk1x_follower;\n" <<
    "\n" <<
    "reg       [size-1:0]  dataa;\n" <<
    "reg       [size-1:0]  datab;\n" <<
    "wire      [size-1:0]  dataa_wire;\n" <<
    "wire      [size-1:0]  datab_wire;\n" <<
    "assign dataa_wire = dataa;\n" <<
    "assign datab_wire = datab;\n" <<
    "\n" <<
    "always @(*)\n" <<
    "begin\n" <<
    "if (mux_sel == 0) \n" <<
    "begin\n";
    if (inputStage) {
        Out << "dataa = inAreg;\n" <<
        "datab = inBreg;\n";
    } else {
        Out << "dataa = inA;\n" <<
        "datab = inB;\n";
    }
    Out << "end\n" <<
    "else \n" <<
    "begin\n";
    if (inputStage) {
        Out << "dataa = inCreg;\n" <<
        "datab = inDreg;\n";
    } else {
        Out << "dataa = inC;\n" <<
        "datab = inD;\n";
    }
    Out << "end\n" <<
    "end\n" <<
    "\n" <<
    "\n" <<
    "\n" <<
    "// DSP multiplier - has two pipeline stages, so both inputs and outputs\n" <<
    "// are registered\n" <<
    "lpm_mult	lpm_mult_component (\n";
    if (lpm_pipeline == 0) {
        Out << ".clock (),\n";
    } else {
        Out << ".clock (clk2x),\n";
    }
    Out << ".dataa (dataa_wire),\n" <<
    ".datab (datab_wire),\n" <<
    ".result (dsp_out),\n" <<
    ".aclr (1'b0),\n" <<
    ".clken (1'b1),\n" <<
    ".sum (1'b0));\n" <<
    "\n" <<
    "defparam\n" <<
    "lpm_mult_component.lpm_hint = \"DEDICATED_MULTIPLIER_CIRCUITRY=YES,MAXIMIZE_SPEED=5\",\n" <<
    "lpm_mult_component.lpm_representation = sign,\n" <<
    "lpm_mult_component.lpm_type = \"LPM_MULT\",\n" <<
    "lpm_mult_component.lpm_pipeline = " << lpm_pipeline << ",\n" <<
    "lpm_mult_component.lpm_widtha = size,\n" <<
    "lpm_mult_component.lpm_widthb = size,\n" <<
    "lpm_mult_component.lpm_widthp = size*2;\n" <<
    "\n" <<
    "\n" <<
    "endmodule\n";
}

void VerilogWriter::printDE4() {
    Out << "module de4 (\n" <<
    "	OSC_50_BANK2,\n" <<
    "    BUTTON,\n" <<
    "    LED,\n" <<
    "	SEG0_D,\n" <<
    "	SEG1_D\n" <<
    ");\n" <<
    "    input OSC_50_BANK2;\n" <<
    "    input [1:0] BUTTON;\n" <<
    "    output [6:0] SEG0_D;\n" <<
    "    output [6:0] SEG1_D;\n" <<
    "    output [7:0] LED;\n" <<
    "\n" <<
    "    de2 de2_inst (\n" <<
    "        .CLOCK_50 (OSC_50_BANK2),\n" <<
    "        .LEDG (LED),\n" <<
    "        .KEY (BUTTON),\n" <<
    "        .SW (),\n" <<
    "        .HEX0 (SEG0_D),\n" <<
    "        .HEX1 (SEG1_D),\n" <<
    "        .HEX2 (),\n" <<
    "        .HEX3 (),\n" <<
    "        .HEX4 (),\n" <<
    "        .HEX5 (),\n" <<
    "        .HEX6 (),\n" <<
    "        .HEX7 ()\n" <<
    "    );\n" <<
    "\n" <<
    "endmodule\n";
}



void VerilogWriter::printDE2() {
    Out <<
    "module de2 (CLOCK_50, KEY, SW, HEX0, HEX1, HEX2, HEX3, HEX4, HEX5, HEX6, HEX7, LEDG);\n" <<
    "    input CLOCK_50;\n" <<
    "    output [7:0] LEDG;\n" <<
    "    input [1:0] KEY;\n" <<
    "    input [15:0] SW;\n" <<
    "    output [6:0] HEX0, HEX1, HEX2, HEX3, HEX4, HEX5, HEX6, HEX7;\n" <<
    "\n" <<
    "    wire  clk;\n";
    if (LEGUP_CONFIG->getParameterInt("MULTIPUMPING")) {
        Out <<
        "    wire  clk2x;\n" <<
        "    wire  clk1x_follower;\n" <<
        "    pll pll_inst (\n" <<
        "        .inclk0 (CLOCK_50),\n" <<
        "        .c0 (clk),\n" <<
        "        .c1 (clk2x)\n" <<
        "    );\n" <<
        "\n";
    }
    Out <<
    "    wire reset = ~KEY[0];\n" <<
    "    wire go = ~KEY[1];\n" <<
    "\n" <<
    "    wire  start;\n" <<
    "    wire [31:0] return_val;\n" <<
    "    wire  finish;\n" <<
    "\n" <<
    "    reg [31:0] return_val_reg;\n" <<
    "    \n" <<
    "    hex_digits h7( .x(return_val_reg[31:28]), .hex_LEDs(HEX7));\n" <<
    "    hex_digits h6( .x(return_val_reg[27:24]), .hex_LEDs(HEX6));\n" <<
    "    hex_digits h5( .x(return_val_reg[23:20]), .hex_LEDs(HEX5));\n" <<
    "    hex_digits h4( .x(return_val_reg[19:16]), .hex_LEDs(HEX4));\n" <<
    "    hex_digits h3( .x(return_val_reg[15:12]), .hex_LEDs(HEX3));\n" <<
    "    hex_digits h2( .x(return_val_reg[11:8]), .hex_LEDs(HEX2));\n" <<
    "    hex_digits h1( .x(return_val_reg[7:4]), .hex_LEDs(HEX1));\n" <<
    "    hex_digits h0( .x(return_val_reg[3:0]), .hex_LEDs(HEX0));\n" <<
    "\n";
    if (LEGUP_CONFIG->getParameterInt("MULTIPUMPING")) {
        Out <<
        "    clock_follower clock_follower_inst (\n" <<
        "        .reset ( reset ),\n" <<
        "        .clk1x ( clk ),\n" <<
        "        .clk2x ( clk2x ),\n" <<
        "        .clk1x_follower ( clk1x_follower )\n" <<
        "    );\n";
    }
    Out <<
    "\n"
    "    top top_inst (\n" <<
    "        .clk (clk),\n";
    if (LEGUP_CONFIG->getParameterInt("MULTIPUMPING")) {
        Out <<
        "        .clk2x (clk2x),\n" <<
        "        .clk1x_follower (clk1x_follower),\n";
    }
    Out <<
    "        .reset (reset),\n" <<
    "        .start (start),\n" <<
    "        .finish (finish),\n" <<
    "        .return_val (return_val)\n" <<
    "    );\n" <<
    "\n" <<
    "    parameter s_WAIT = 3'b001, s_START = 3'b010, s_EXE = 3'b011,\n" <<
    "                s_DONE = 3'b100;\n" <<
    "\n" <<
    "    // state registers\n" <<
    "    reg [3:0] y_Q, Y_D;\n" <<
    "\n" <<
    "    assign LEDG[3:0] = y_Q;\n" <<
    "\n" <<
    "    // next state\n" <<
    "    always @(*)\n" <<
    "    begin\n" <<
    "        case (y_Q)\n" <<
    "            s_WAIT: if (go) Y_D = s_START; else Y_D = y_Q;\n" <<
    "\n" <<
    "            s_START: Y_D = s_EXE;\n" <<
    "\n" <<
    "            s_EXE: if (!finish) Y_D = s_EXE; else Y_D = s_DONE;\n" <<
    "\n" <<
    "            s_DONE: Y_D = s_DONE;\n" <<
    "\n" <<
    "            default: Y_D = 3'bxxx;\n" <<
    "        endcase\n" <<
    "    end\n" <<
    "\n" <<
    "    // current state\n" <<
    "    always @(posedge clk)\n" <<
    "    begin\n" <<
    "        if (reset) // synchronous clear\n" <<
    "            y_Q <= s_WAIT;\n" <<
    "        else\n" <<
    "            y_Q <= Y_D;\n" <<
    "    end\n" <<
    "\n" <<
    "    always @(posedge clk)\n" <<
    "        if (y_Q == s_EXE && finish)\n" <<
    "            return_val_reg <= return_val;\n" <<
    "        else if (y_Q == s_DONE)\n" <<
    "            return_val_reg <= return_val_reg;\n" <<
    "        else\n" <<
    "            return_val_reg <= 0;\n" <<
    "\n" <<
    "\n" <<
    "    assign start = (y_Q == s_START);\n" <<
    "endmodule\n" <<
    "\n";
}

void VerilogWriter::printHex() {
    Out << "module hex_digits(x, hex_LEDs);\n" <<
    "    input [3:0] x;\n" <<
    "    output [6:0] hex_LEDs;\n" <<
    "    \n" <<
    "    assign hex_LEDs[0] = (~x[3] & ~x[2] & ~x[1] & x[0]) |\n" <<
    "                            (~x[3] & x[2] & ~x[1] & ~x[0]) |\n" <<
    "                            (x[3] & x[2] & ~x[1] & x[0]) |\n" <<
    "                            (x[3] & ~x[2] & x[1] & x[0]);\n" <<
    "    assign hex_LEDs[1] = (~x[3] & x[2] & ~x[1] & x[0]) |\n" <<
    "                            (x[3] & x[1] & x[0]) |\n" <<
    "                            (x[3] & x[2] & ~x[0]) |\n" <<
    "                            (x[2] & x[1] & ~x[0]);\n" <<
    "    assign hex_LEDs[2] = (x[3] & x[2] & ~x[0]) |\n" <<
    "                            (x[3] & x[2] & x[1]) |\n" <<
    "                            (~x[3] & ~x[2] & x[1] & ~x[0]);\n" <<
    "    assign hex_LEDs[3] = (~x[3] & ~x[2] & ~x[1] & x[0]) | \n" <<
    "                            (~x[3] & x[2] & ~x[1] & ~x[0]) | \n" <<
    "                            (x[2] & x[1] & x[0]) | \n" <<
    "                            (x[3] & ~x[2] & x[1] & ~x[0]);\n" <<
    "    assign hex_LEDs[4] = (~x[3] & x[0]) |\n" <<
    "                            (~x[3] & x[2] & ~x[1]) |\n" <<
    "                            (~x[2] & ~x[1] & x[0]);\n" <<
    "    assign hex_LEDs[5] = (~x[3] & ~x[2] & x[0]) | \n" <<
    "                            (~x[3] & ~x[2] & x[1]) | \n" <<
    "                            (~x[3] & x[1] & x[0]) | \n" <<
    "                            (x[3] & x[2] & ~x[1] & x[0]);\n" <<
    "    assign hex_LEDs[6] = (~x[3] & ~x[2] & ~x[1]) | \n" <<
    "                            (x[3] & x[2] & ~x[1] & ~x[0]) | \n" <<
    "                            (~x[3] & x[2] & x[1] & x[0]);\n" <<
    "    \n" <<
    "endmodule\n";

}


void VerilogWriter::printRAMModule() {
    RTLModule *m = new RTLModule("ram_dual_port");    
    
    //initial all the params to specify size of the altsynrams to 0 in the ram
    m->addParam("width_a", "0");
    m->addParam("width_b", "0");
    m->addParam("widthad_a", "0");
    m->addParam("widthad_b", "0");
    m->addParam("numwords_a", "0");
    m->addParam("numwords_b", "0");
    m->addParam("init_file", "\"UNUSED\"");

    RTLSignal *clk  = m->addIn("clk");

    RTLSignal *addr_a = m->addIn("address_a", RTLWidth("(widthad_a-1)"));
    RTLSignal *addr_b = m->addIn("address_b", RTLWidth("(widthad_b-1)"));
    RTLSignal *we_a   = m->addIn("wren_a");
    RTLSignal *we_b   = m->addIn("wren_b");
    RTLSignal *data_a = m->addIn("data_a", RTLWidth("(width_a-1)"));
    RTLSignal *data_b = m->addIn("data_b", RTLWidth("(width_b-1)"));
    RTLSignal *q_a   = m->addOut("q_a", RTLWidth("(width_a-1)"));
    RTLSignal *q_b   = m->addOut("q_b", RTLWidth("(width_b-1)"));

    // Altera specific RAM
    RTLModule *a = m->addModule("altsyncram", "altsyncram_component");

    RTLConst *one   = m->addConst("1");
    RTLConst *zero  = m->addConst("0");
    RTLConst *blank = m->addConst("");

    // need this to avoid:
    // # ** Warning: (vsim-3016) div_const.v(111): Port type is incompatible
    // with connection (port 'clk').
    RTLSignal *clk_wire = m->addWire("clk_wire");
    clk_wire->connect(clk);

    // specify the inputs and outputs for the altsynram module 
    a->addIn("clock0")->connect(clk_wire);
    a->addIn("clock1")->connect(one);
    a->addIn("clocken0")->connect(one);
    a->addIn("clocken1")->connect(one);
    a->addIn("clocken2")->connect(one);
    a->addIn("clocken3")->connect(one);
    a->addIn("aclr0")->connect(zero);
    a->addIn("aclr1")->connect(zero);
    a->addIn("addressstall_a")->connect(zero);
    a->addIn("addressstall_b")->connect(zero);
    a->addOut("eccstatus")->connect(blank);
    a->addIn("address_a")->connect(addr_a);
    a->addIn("address_b")->connect(addr_b);
    a->addIn("wren_a")->connect(we_a);
    a->addIn("wren_b")->connect(we_b);
    a->addIn("rden_a")->connect(one);
    a->addIn("rden_b")->connect(one);
    a->addIn("data_a")->connect(data_a);
    a->addIn("data_b")->connect(data_b);
    a->addOut("q_a")->connect(q_a);
    a->addOut("q_b")->connect(q_b);    
    RTLSignal *byteena_a = a->addIn("byteena_a");    
    RTLSignal *byteena_b = a->addIn("byteena_b");

    if (alloc->usesGenericRAMs()) {        
        m->addParam("width_be_a", "0");
        m->addParam("width_be_b", "0");
        RTLSignal *byteena_m_a = m->addIn("byteena_a", RTLWidth("width_be_a-1"));
        RTLSignal *byteena_m_b = m->addIn("byteena_b", RTLWidth("width_be_b-1"));
        byteena_a->connect(byteena_m_a);
        byteena_b->connect(byteena_m_b);
    } else {
        // if we don't use generic RAMs, byteenab will always be 1 
        byteena_a->connect(one);
        byteena_b->connect(one);
    }

    if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING") ){
        a->addParam("operation_mode", "\"BIDIR_DUAL_PORT\"");
    } else {
        a->addParam("operation_mode", "\"SINGLE_PORT\"");
    }

    // can be OLD_DATA , DONT_CARE or NEW_DATA_NO_NBE_READ
    a->addParam("read_during_write_mode_mixed_ports", "\"OLD_DATA\""); 
    a->addParam("init_file", "init_file");
    a->addParam("lpm_hint", "\"ENABLE_RUNTIME_MOD=NO\"");
    a->addParam("lpm_type", "\"altsyncram\"");
    a->addParam("power_up_uninitialized", "\"FALSE\"");
    
    // the space actually matters for simulation
    if (LEGUP_CONFIG->getDeviceFamily() == "CycloneII") {
        a->addParam("intended_device_family", "\"Cyclone II\"");
    } else if (LEGUP_CONFIG->getDeviceFamily() == "StratixIV") {
        a->addParam("intended_device_family", "\"Stratix IV\"");
    } else {
        llvm_unreachable("Unrecognized device family!");
    }
    a->addParam("clock_enable_input_a", "\"BYPASS\"");
    a->addParam("clock_enable_input_b", "\"BYPASS\"");
    a->addParam("clock_enable_output_a", "\"BYPASS\"");
    a->addParam("clock_enable_output_b", "\"BYPASS\"");
    a->addParam("outdata_aclr_a", "\"NONE\"");
    a->addParam("outdata_aclr_b", "\"NONE\"");
    a->addParam("outdata_reg_a", "\"UNREGISTERED\"");
    a->addParam("outdata_reg_b", "\"UNREGISTERED\"");
    a->addParam("numwords_a", "numwords_a");
    a->addParam("numwords_b", "numwords_b");
    a->addParam("widthad_a", "widthad_a");
    a->addParam("widthad_b", "widthad_b");
    a->addParam("width_a", "width_a");
    a->addParam("width_b", "width_b");
    
    a->addParam("address_reg_b","\"CLOCK0\"");
    a->addParam("byteena_reg_b","\"CLOCK0\"");
    a->addParam("indata_reg_b","\"CLOCK0\"");
    a->addParam("wrcontrol_wraddress_reg_b","\"CLOCK0\"");

    if (alloc->usesGenericRAMs()){
        a->addParam("width_byteena_a", "width_be_a");
        a->addParam("width_byteena_b", "width_be_b");
    }else{
        a->addParam("width_byteena_a", "1");
        a->addParam("width_byteena_b", "1");
    }

    // doesn't work on StratixII:
    //"    altsyncram_component.read_during_write_mode_port_a = "DONT_CARE","

    printRTL(m);
    delete m;
}

void VerilogWriter::printMemoryVariablesSignals(std::string inputPrefix, 
    std::string outputPrefix, std::string postfix) {

    Out << outputPrefix << " " << "memory_controller" << "_enable" <<
    postfix << ";\n";

    Out << outputPrefix << " [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] " <<
        "memory_controller" << "_address" << postfix << ";\n";

    Out << outputPrefix << " " << "memory_controller" << "_write_enable" <<
        postfix << ";\n";
 
    Out << outputPrefix << " [`MEMORY_CONTROLLER_DATA_SIZE-1:0] " <<
        "memory_controller" << "_in" << postfix << ";\n";

    if (alloc->usesGenericRAMs()){
        Out << outputPrefix << " [1:0] " << "memory_controller" << "_size" << 
            postfix << ";\n";
    }
    Out << inputPrefix << " [`MEMORY_CONTROLLER_DATA_SIZE-1:0] " <<
        "memory_controller" << "_out" << postfix << ";\n";
    Out << "\n";
}   


void VerilogWriter::printMemoryVariables(bool top) {

    std::string outputPrefix, inputPrefix;
    if (!top) {
        outputPrefix = "output reg";
        inputPrefix = "input wire";
    } else {
        outputPrefix = "wire";
        inputPrefix = "wire";
    }

    //this is in top module creating signals for connect memory controller and main
    Out << inputPrefix << " " << "memory_controller" << "_waitrequest;\n";
    printMemoryVariablesSignals(inputPrefix, outputPrefix, "_a");
    printMemoryVariablesSignals(inputPrefix, outputPrefix, "_b");
}

void VerilogWriter::printVerilogTestbench() {

    RTLModule *m = new RTLModule("main_tb");

    RTLSignal *clk;
    std::string clk_name;
    if (LEGUP_CONFIG->getParameterInt("MULTIPUMPING")) {
        clk_name = "clk_orig";
        clk  = m->addWire("clk");
    } else {
        clk_name = "clk";
        clk = m->addReg("clk");
    }
    RTLSignal *reset  = m->addReg("reset");
    RTLSignal *start  = m->addReg("start");
    RTLSignal *return_val  = m->addWire("return_val", RTLWidth("31"));
    RTLSignal *finish  = m->addWire("finish");

    RTLModule *t = m->addModule("top", "top_inst");
    t->addIn("clk")->connect(clk);

    if (LEGUP_CONFIG->getParameterInt("MULTIPUMPING")) {
        RTLSignal *clk_orig  = m->addReg("clk_orig");
        RTLSignal *clk2x  = m->addWire("clk2x");
        RTLSignal *clk1x_follower  = m->addWire("clk1x_follower");

        t->addIn("clk2x")->connect(clk2x);
        t->addIn("clk1x_follower")->connect(clk1x_follower);

        // create pll
        /*pll	pll_inst (
            .inclk0 ( clk_orig ), // 50 MHz
            .c0 ( clk ), // 50 MHz
            .c1 ( clk2x ) // 100 MHz
            );
            */
        RTLModule *pll = m->addModule("pll", "pll_inst");
        pll->addIn("inclk0")->connect(clk_orig);
        // must have 1x clock coming from the same PLL as the 2x clock to avoid
        // large clock skew that can cause hold-time violations
        pll->addOut("c0")->connect(clk);
        pll->addOut("c1")->connect(clk2x);

        // create clock follower
        /*
        clock_follower clock_follower_inst (
            .reset ( reset ),
            .clk1x ( clk ),
            .clk2x ( clk2x ),
            .clk1x_follower ( clk1x_follower )
        );
        */
        RTLModule *clock_follower = m->addModule("clock_follower",
                "clock_follower_inst");
        clock_follower->addIn("reset")->connect(reset);
        clock_follower->addIn("clk1x")->connect(clk);
        clock_follower->addIn("clk2x")->connect(clk2x);
        clock_follower->addOut("clk1x_follower")->connect(clk1x_follower);
    }

    t->addIn("reset")->connect(reset);
    t->addIn("start")->connect(start);
    t->addOut("finish")->connect(finish);
    t->addOut("return_val")->connect(return_val);

    std::string old_body = m->getBody();
    raw_string_ostream body (old_body);

    body  <<
        "\n" <<
        "initial \n" <<
        "    " << clk_name << " = 0;\n" <<
        "always @(" << clk_name << ")\n" <<
        "    " << clk_name << " <= #10 ~" << clk_name << ";\n" <<
        "\n" <<
        "initial begin\n" <<
        "//$monitor(\"At t=%t clk=%b %b %b %b %d\", $time, clk, reset, " <<
        "start, finish, return_val);\n" <<
        "@(negedge clk);\n" <<
        "reset <= 1;\n" <<
        "@(negedge clk);\n" <<
        "reset <= 0;\n" <<
        "start <= 1;\n" <<
        "\n" <<
        "end\n" <<
        "\n" <<
        "always@(finish) begin\n" <<
        "    if (finish == 1) begin\n" <<
        "        $display(\"At t=%t clk=%b finish=%b return_val=%d\", " <<
        "$time, clk, finish, return_val);\n" <<
        "        $display(\"Cycles: %d\", ($time-50)/20);\n" <<
        "        $finish;\n" <<
        "    end\n" <<
        "end\n";

    m->setBody(body .str());
    printRTL(m);
    delete m;
}

// we should strip the altsyncrams for non-constnat global variables
// when hw/sw partitioning
bool VerilogWriter::stripRAM(const Value *R) {
    // if pure h/w then don't strip anything
    if (LEGUP_CONFIG->numAccelerators() == 0) return false;

    if (const GlobalVariable *G = dyn_cast<GlobalVariable>(R)) {
        // don't strip constant values
        if (!G->isConstant()) {
            return true;
        }
    }
    return false;
}

void VerilogWriter::printMemCtrlModuleHeader() {
    Out << "`timescale 1 ns / 1 ns\n";
    Out << "module memory_controller" << "\n" <<
        "(" << "\n" <<
        "\t" << "clk," << "\n" <<
        "\t" << "memory_controller_address_a," << "\n" <<
        "\t" << "memory_controller_address_b," << "\n" <<
        "\t" << "memory_controller_enable_a," << "\n" <<
        "\t" << "memory_controller_enable_b," << "\n" <<
        "\t" << "memory_controller_write_enable_a," << "\n" <<
        "\t" << "memory_controller_write_enable_b," << "\n" <<
        "\t" << "memory_controller_in_a," << "\n"
        "\t" << "memory_controller_in_b," << "\n";
    if (alloc->usesGenericRAMs()) {
        Out <<
        "\t" << "memory_controller_size_a," << "\n";
        Out <<
        "\t" << "memory_controller_size_b," << "\n";
    }

    	Out << "\tmemory_controller_waitrequest,\n";
    Out <<
        "\t" << "memory_controller_out_reg_a," << "\n" <<
        "\t" << "memory_controller_out_reg_b" << "\n" <<
        ");" << "\n" <<
        "" << "\n";
}

void VerilogWriter::printMemCtrlVariablesSignals(std::string postfix) {
    Out <<"input [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] memory_controller_address" <<
        postfix << ";\n" <<
        "input memory_controller_enable" << postfix <<";\n" << 
        "input memory_controller_write_enable" << postfix << ";" << "\n";

    // memory_controller_out_prev is used for storing 
    // the the previous output value if the memory controller
    // is not reading new values.
    if (alloc->usesGenericRAMs()) {
        Out << "input [64-1:0] memory_controller_in" << postfix << ";" << "\n" <<
            "input [1:0] memory_controller_size" << postfix << ";" << "\n";
        Out << "output reg [64-1:0] memory_controller_out_reg" << postfix << ";" << "\n" <<
            "reg [64-1:0] memory_controller_out_prev" << postfix << ";" << "\n" <<
            "reg [64-1:0] memory_controller_out" << postfix << ";" << "\n" << "\n";
    } else {
        Out << "input [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_in" << 
            postfix << ";" << "\n" <<
            "output reg [`MEMORY_CONTROLLER_DATA_SIZE-1:0] " <<
            "memory_controller_out_reg" << postfix << ";" << "\n" <<
            "reg [`MEMORY_CONTROLLER_DATA_SIZE-1:0] "<< "memory_controller_out_prev" 
            << postfix << ";" << "\n" <<
            "reg [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_out" << 
            postfix << ";" << "\n" << "\n";        
    }
    
    Out << "reg memory_controller_enable_reg" << postfix << ";\n"; 
}    


void VerilogWriter::printMemCtrlVariables() {
    Out << "" << "\n" <<
        "input clk;" << "\n";
	    Out << "input memory_controller_waitrequest;\n";
        printMemCtrlVariablesSignals("_a");
        printMemCtrlVariablesSignals("_b");       
}

void VerilogWriter::printMemCtrlRAMs() {
    for (Allocation::const_ram_iterator i = alloc->ram_begin(), e = alloc->ram_end();
            i != e; ++i) {
        const RAM *R = *i;
        if (stripRAM(R->getValue())) continue;
        Out << "\n";
        printRamInstance(R);
        Out << "\n";
    }
}

void VerilogWriter::printRamInstance(const RAM *R) {

    std::string name = R->getName();
    unsigned addresswidth = R->getAddrWidth();
    unsigned datawidth = R->getDataWidth();

    if (!LEGUP_CONFIG->getParameterInt("LOCAL_RAMS")) {

        Out << "reg [" << addresswidth-1 << ":0] " << name << "_address_a" << ";\n";
        Out << "reg [" << addresswidth-1 << ":0] " << name << "_address_b" << ";\n";
        Out << "reg " << name << "_write_enable_a" << ";\n";
        Out << "reg " << name << "_write_enable_b" << ";\n";
        Out << "reg [" << datawidth-1 << ":0] " << name << "_in_a" << ";\n";
        Out << "reg [" << datawidth-1 << ":0] " << name << "_in_b" << ";\n";
        Out << "wire [" << datawidth-1 << ":0] " << name << "_out_a" << ";\n";
        Out << "wire [" << datawidth-1 << ":0] " << name << "_out_b" << ";\n";

        if (alloc->usesGenericRAMs() && R->isStruct()) {
            //if R is Struct 
            Out << "reg [8-1:0] " << name << "_byteena_a;\n";    
            Out << "reg [8-1:0] " << name << "_byteena_b;\n";    
        }
        Out << "\n";
    }


    Out << "// " << getValueStr(R->getValue()) << '\n';

    Out << "ram_dual_port " << name << " (" << "\n" <<
        "\t" << ".clk( clk )," << "\n" <<
        "\t" << ".address_a( " << name << "_address_a )," << "\n" <<
        "\t" << ".address_b( " << name << "_address_b )," << "\n" <<
        "\t" << ".wren_a( " << name << "_write_enable_a )," << "\n" <<
        "\t" << ".wren_b( " << name << "_write_enable_b )," << "\n" <<
        "\t" << ".data_a( " << name << "_in_a )," << "\n"<<
        "\t" << ".data_b( " << name << "_in_b )," << "\n";
    if (alloc->usesGenericRAMs()) {
        if (R->isStruct()) {        //if R is Struct
            Out << "\t" << ".byteena_a( " << name << "_byteena_a )," << "\n";
            Out << "\t" << ".byteena_b( " << name << "_byteena_b )," << "\n";
        } else {
            Out << "\t" << ".byteena_a( 1'b1 )," << "\n";
            Out << "\t" << ".byteena_b( 1'b1 )," << "\n";
        }
    }
    Out << "\t" << ".q_a( " << name << "_out_a )" << ",\n" <<
    "\t" << ".q_b( " << name << "_out_b)" << "\n" << ");\n";

    // parameters
    Out << "defparam " << name << ".width_a = " << datawidth << ";\n";
    Out << "defparam " << name << ".width_b = " << datawidth << ";\n";
    Out << "defparam " << name << ".widthad_a = " << addresswidth << ";\n";
    Out << "defparam " << name << ".widthad_b = " << addresswidth << ";\n";
    if (R->isStruct()) {
        Out << "defparam " << name << ".width_be_a = " << 8 << ";\n";
        Out << "defparam " << name << ".width_be_b = " << 8 << ";\n";
    } else if (alloc->usesGenericRAMs()) {
        Out << "defparam " << name << ".width_be_a = " << 1 << ";\n";
        Out << "defparam " << name << ".width_be_b = " << 1 << ";\n";
    }
    Out << "defparam " << name << ".numwords_a = " << R->getElements() << ";\n";
    Out << "defparam " << name << ".numwords_b = " << R->getElements() << ";\n";


    if (R->getInitializer()) {
        Out << "defparam " << name << ".init_file = ";
        Out << "\"" << R->getMifFileName() << "\";\n";
    }
}

void VerilogWriter::printMemoryControllerSignals(std::string postfix) {
    Out << "wire [`MEMORY_CONTROLLER_TAG_SIZE-1:0] tag" << postfix 
        <<";\n";

    // As we are using the select signal to select the output data
    // pre_Tag is no longer needed here.
    Out << "assign tag" << postfix << " = " <<
        "memory_controller_address" << postfix << "[" << "`MEMORY_CONTROLLER_ADDR_SIZE-1"
        << ":" << "`MEMORY_CONTROLLER_ADDR_SIZE-`MEMORY_CONTROLLER_TAG_SIZE];\n";
    Out << "reg [2:0] prevAddr" << postfix <<";\n";

    if (alloc->usesGenericRAMs()) {
        Out << "reg [1:0] prevSize" << postfix << ";\n";

        //prevSize_and is used for alignment check  
        Out << "reg [2:0] prevSize" << postfix << "_and;\n";
    }

    indent0 = std::string(1, '\t');
    indent = std::string(2, '\t');

    Out << "\nalways @(posedge clk)" << "\n";
    Out << "begin" << "\n";
    Out << indent0 << "prevAddr" << postfix <<" <= memory_controller_address" << postfix << "[2:0];\n";

    if (alloc->usesGenericRAMs()) {
        Out << indent0 << "prevSize" << postfix <<" <= memory_controller_size" << postfix << ";\n";
    }
    Out << "end" << "\n";
}


void VerilogWriter::printMemoryController() {

    // Created select signals for each altsynram. if the input tag matches the altsynram's tag
    // the altsynram's select signal will be 1. Then we store it for 1 cycle, then expand it 
    // and AND with the output of altsynram. At the end of mem ctrl, there is an OR gate to collect all outputs.

    printMemCtrlModuleHeader();

    printMemCtrlVariables();

    for (Allocation::const_ram_iterator i =
            alloc->ram_begin(), e = alloc->ram_end(); i != e; ++i) {
        const RAM *R = *i;
        R->generateMIF();
    }

    if (LEGUP_CONFIG->getParameterInt("LOCAL_RAMS")) {
        Out << "endmodule " << "\n";
        return;
    }

    printMemCtrlRAMs();
    
    printMemoryControllerSignals("_a");    
    printMemoryControllerSignals("_b");

    printRAMSignals("_a");
    printRAMSignals("_b");

    Out << "" << "\n" <<
        "endmodule " << "\n";
}

void VerilogWriter::printRAMTag(const RAM *R, std::string postfix) {
    if (stripRAM(R->getValue())) return;

    if (!R->isStruct()) {

        /*
       avalon_mem = memory_controller_address[5-1+2:0] + SRAM_offset;
       memory_controller_waitrequest = avalon_waitrequest;
       avalon_read = memory_controller_enable & ~memory_controller_write_enable;
       avalon_write = memory_controller_enable & memory_controller_write_enable;
       avalon_data = memory_controller_in[32-1:0];
       */

        // ignore lower bits if necessary
        int bytes = R->getDataWidth() / 8;
        int ignore = (bytes == 0) ? 0 : (int)log2(bytes);

        //ALTSYNRAM1_address_a = memory_controller_address_a[5-1+2:2]&{5{select_ALTSYNRAM1}};
        Out << indent0 << R->getName() <<
            "_address" << postfix << " = memory_controller_address" << postfix <<
            " [" << R->getAddrWidth() << "-1+" << ignore << ":" << ignore << "]"<<
            " & " << "{" << R->getAddrWidth() << "{select_"<< R->getName() << postfix<< "}}" <<
            ";\n";

        //ALTSYNRAM1_write_enable_a = memory_controller_write_enable_a & select_ALTSYNRAM1;    
        Out << indent0 << R->getName() << "_write_enable" << postfix << 
            " = memory_controller_write_enable" << postfix << 
            " & select_" <<  R->getName() << postfix <<";\n";

        //ALTSYNRAM1_in_a[32-1:0] = memory_controller_in_a[32-1:0] ;
        Out << indent0 << R->getName() << "_in" << postfix << 
            " [" << R->getDataWidth() << "-1:0] = memory_controller_in" << postfix << "[" <<
            R->getDataWidth() << "-1:0];\n";

        Out << "\n";

    } else {

        Out << indent0 << R->getName() << "_address" << postfix << 
            " = memory_controller_address" << postfix << "[" << 
            R->getAddrWidth() + 3 << "-1:3] & "<< "{" << R->getAddrWidth() <<
            "{select_" << R->getName() << postfix <<"}}" << ";\n";

        Out << indent0 << R->getName() << "_write_enable" << postfix << 
            " = memory_controller_write_enable" << postfix <<
            " & select_" <<  R->getName() << postfix << ";\n";

        Out << indent << "\t\t" << R->getName() << "_in" << postfix << " = 0;\n";

        Out << indent << "case(memory_controller_size" << postfix << ")\n";

        Out << indent << "\t3:\n";
        Out << indent << "\tbegin\n";
        Out << indent << "\t\t" << R->getName() <<
            "_in" << postfix << "[64-1:0] = memory_controller_in" << postfix << "[64-1:0];\n";
        Out << indent << "\t\t" << R->getName() << "_byteena" << postfix << " = 8'b11111111;\n";
        Out << indent << "\tend\n";

        Out << indent << "\t2:\n";
        Out << indent << "\tbegin\n";
        Out << indent << "\t\tif (memory_controller_address" << postfix << " [2:2] == 0)\n";
        Out << indent << "\t\tbegin\n";
        Out << indent << "\t\t\t" << R->getName() <<
            "_in" << postfix << "[32-1:0] = memory_controller_in" << postfix << "[32-1:0];\n";
        Out << indent << "\t\t\t" << R->getName() <<
            "_byteena" << postfix << " = 8'b00001111;\n";
        Out << indent << "\t\tend\n";
        Out << indent << "\t\telse\n";
        Out << indent << "\t\tbegin\n";
        Out << indent << "\t\t\t" << R->getName() <<
            "_in" << postfix << "[64-1:32] = memory_controller_in" << postfix << "[32-1:0];\n";
        Out << indent << "\t\t\t" << R->getName() <<
            "_byteena" << postfix << " = 8'b11110000;\n";
        Out << indent << "\t\tend\n";
        Out << indent << "\tend\n";

        Out << indent << "\t1:\n";
        Out << indent << "\tbegin\n";
        Out << indent << "\t\tcase (memory_controller_address" << postfix << "[2:1])\n";
        for (int c = 0; c < 4; c++) {
            Out << indent << "\t\t\t" << c << ":\n";
            Out << indent << "\t\t\tbegin\n";
            Out << indent << "\t\t\t\t" << R->getName() <<
                "_in" << postfix << "[" << ((c * 16) + 16) << "-1:" << (c * 16) << "] " <<
                "= memory_controller_in" << postfix << "[16-1:0];\n";
            Out << indent << "\t\t\t\t" << R->getName() << "_byteena" << postfix << " " <<
                "= 8'd" << (3 << (c * 2)) << ";\n";
            Out << indent << "\t\t\tend\n";
        }
        Out << indent << "\t\tendcase\n";
        Out << indent << "\tend\n";

        Out << indent << "\t0:\n";
        Out << indent << "\t\tcase (memory_controller_address" << postfix << "[2:0])\n";
        for (int i = 0; i < 8; i++) {
            Out << indent << "\t\t\t" << i << ":\n";
            Out << indent << "\t\t\tbegin\n";
            Out << indent << "\t\t\t\t" << R->getName() <<
                "_in" << postfix << "[" << 8 * (i + 1) << "-1:"<< 8 * i << "] = " <<
                "memory_controller_in" << postfix << "[8-1:0];\n";
            Out << indent << "\t\t\t\t" << R->getName() << "_byteena" << postfix << " = " <<
                "8'd" << (1 << i) << ";\n";
            Out << indent << "\t\t\tend\n";
        }
        Out << indent << "\tendcase\n";

        Out << indent << "endcase\n";

        Out << "\n";
    }
    // debugging
    //Out << "always @(posedge clk)" << "\n";
    //Out << indent0 << "$display(\"addr:%x\",memory_controller_address);\n";
    /*
       Out << indent << "$display(\"" << R->getName() << "_address" <<
            ": %d we: %d in: %d out: %d\"," <<
       R->getName() << "_address," <<
       R->getName() << "_write_enable," <<
       R->getName() << "_in," <<
       R->getName() << "_out);\n";
       */
}

void VerilogWriter::printRAMTagCase(std::string postfix) {

    Out << "always @(*)" << "\n";
    Out << "begin" << "\n";

    for (Allocation::const_ram_iterator ram = alloc->ram_begin(), e =
            alloc->ram_end(); ram != e; ++ram) {
        printRAMTag(*ram, postfix);
    }
    Out << "end" << "\n";
}


void VerilogWriter::printRAMSignals(std::string postfix) {
    Out << "\n";   
    if (alloc->getNumRAMs() == 0) return;

    // if the altsynram is not storing struct, use the signal to check addr alignment
    Out << "reg " << "[2:0] select_not_struct" << postfix << ";\n";
    Out << "\n";

    for (Allocation::const_ram_iterator i = alloc->ram_begin(), e = alloc->ram_end();
            i != e; ++i) {
        const RAM *R = *i;
		if (stripRAM(R->getValue())) continue;

        // wire select_ALTSYNRAM1_a;
        // assign select_ALTSYNRAM1_a = (tag_a ==`TAG_ALTSYNRAM1) ;
        Out << "wire select_" << R->getName() << postfix << ";\n";
        Out << "assign " << "select_" << R->getName() << postfix << 
            " = (tag" << postfix << " ==" << "`" << R->getTag() << ");\n";

        // reg select_ALTSYNRAM1_a;
        Out<< "reg " << "select_" <<  R->getName() << "_reg" << postfix << ";\n";

        unsigned datawidth = R->getDataWidth();

        // if the altsynram is not storing struct, forward the output with full bitwidth to the
        // big OR at the end of mem ctrl. Otherwise, add more signals for selecting different bytes. 
        if(!R->isStruct()){

            // wire[31:0] memory_controller_ALTSYNRAM1_a;
            // assign memory_controller_ALTSYNRAM1_a = {32{select_ALTSYNRAM1_a}} & ALTSYNRAM1_out_a;
            Out << "wire " << "[" << datawidth-1 << ":0] memory_controller_"<<
                R->getName() << "_out" << postfix << ";\n"; 

            Out << "assign " << "memory_controller_"<<
                R->getName() << "_out" << postfix << " = {" << datawidth << 
                "{ select_" << R->getName() <<"_reg" << postfix << "}} & "<< 
                R->getName() << "_out" << postfix << ";\n";
            Out << "\n";

        } else {
            Out << "reg " << "[" << datawidth-1 << ":0] memory_controller_"<<
                R->getName() << "_out" << postfix << ";\n";        
    
            //if the altsynram is storing a struct,
            //memory_controller_ALTSYNRAM_out_struct_a       
            //is added to store the full 64-bit output
            //memory_controller_ALTSYNRAM_out_a
            //then selects specific bits from memory_controller_ALTSYNRAM_out_struct_a.
            Out << "wire " << "[" << datawidth-1 << ":0] memory_controller_"<<
                R->getName() << "_out_struct" << postfix << ";\n";
  
            Out << "assign " << "memory_controller_"<<
                R->getName() << "_out_struct" << postfix << " = {" << datawidth << 
                "{ select_" << R->getName() <<"_reg" << postfix << "}} & "<< 
                R->getName() << "_out" << postfix << ";\n";
            Out << "\n";

        }    
    }    
    printRAMTagCase(postfix);

    // need to steer output based on previous tag
    printPrevTagCase(postfix);

    Out << "\nalways @(posedge clk)\n";
    Out << "begin" << "\n";

    if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING") && (LEGUP_CONFIG->numAccelerators() > 0)) {	
    	Out << "if (!memory_controller_waitrequest)\n"<<
	"begin\n";
    }
    Out << "memory_controller_out_reg" << postfix << 
        " <= memory_controller_out" << postfix << ";\n";
    Out << "memory_controller_enable_reg" << postfix <<
        " <= memory_controller_enable" << postfix << ";\n";

    for (Allocation::const_ram_iterator i = alloc->ram_begin(), e = alloc->ram_end();
            i != e; ++i) {
        const RAM *R = *i;
        if (stripRAM(R->getValue())) continue;
        Out << "select_" << R->getName() << "_reg" << postfix << 
            " <= select_" << R->getName() << postfix << ";\n";
    }

    if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING") && (LEGUP_CONFIG->numAccelerators() > 0)) {	
    	Out << "end\n";
    }
    Out << "end" << "\n";\

    // debugging
    /*
       Out << "always @(*)\n" <<
       "$display(\"memory_controller_out=%d prevTag=%d\", " <<
       "memory_controller_out, prevTag);\n";
       */

}

void VerilogWriter::printPrevTagCase(std::string postfix) {
    Out << "always @(*)\n";
    Out << "begin" << "\n";
    Out << indent0 << "select_not_struct" << postfix << " [2:0] = 3'b0";
    for (Allocation::const_ram_iterator i = alloc->ram_begin(), e = alloc->ram_end();
        i != e; ++i) {
        const RAM *R = *i;
        if (stripRAM(R->getValue())) continue;
        if (R->isStruct()) continue;

        int bytes = R->getDataWidth() / 8;
        int ignore = (bytes == 0) ? 0 : (int)log2(bytes);
        if (ignore > 0) {
            // We do not support reading a single byte from an integer etc.
            // all pointers must be aligned to the word size of the ram
            // NOTE: memory_controller_address can be temporarily wrong
            // (due to being a combination signal) so we check the
            // prevAddr register instead
            Out<<" | {"<<ignore<<"{select_" << R->getName() << "_reg" <<
                postfix << "}}";
        }
    }
    Out<<";\n";

    Out << indent0 << "if (prevAddr" << postfix << "[2:0] & select_not_struct"
        << postfix << "[2:0] != 0 && memory_controller_enable" <<postfix << ")\n";
    Out << indent0 << "begin\n";
    Out << indent0 << "\t$display(\"Error: memory address not " <<
        "aligned to ram word size!\");\n";
    Out << indent0 << "\t$finish;\n";
    Out << indent0 << "end\n\n";

    // check the mem addr alignment
    printAddrAlignmentCheck(postfix);

    // if the altsynram stores struct
    for (Allocation::const_ram_iterator i = alloc->ram_begin(), e =
            alloc->ram_end(); i != e; ++i) {

        const RAM *R = *i;

        if (stripRAM(R->getValue())) continue;

        if(R->isStruct()){
            printPrevAddr(R, postfix);
            Out << "\n";
        }
    }

    // memory_controller_out_prev_a=memory_controller_out_reg_a&&{64{!memory_controller_enable_reg}
    if (alloc->usesGenericRAMs()) {
        Out << indent0 << "memory_controller_out_prev" << postfix << " = " <<
            "memory_controller_out_reg" << postfix << " & " << "{ 64{" <<
            "!memory_controller_enable_reg" << postfix << "}};\n";
    } else {
        Out << indent0 << "memory_controller_out_prev" << postfix << " = " <<
            "memory_controller_out_reg" << postfix << " & " <<
            "{ `MEMORY_CONTROLLER_DATA_SIZE {" <<
            "!memory_controller_enable_reg" << postfix << "}};\n";
    }

    //memory_controller_out_a =  memory_controller_main_0_array_0_a_out | memory_controller_main_0_array_1_a_out
    Out << indent0 << "memory_controller_out" << postfix << " = 1'b0 " <<
        "| " << "memory_controller_out_prev" << postfix ;    //just in case there is no output     
    for (Allocation::const_ram_iterator i = alloc->ram_begin(), e =
            alloc->ram_end(); i != e; ++i) {
        const RAM *R = *i;

        if (stripRAM(R->getValue())) continue;
        Out<< " | memory_controller_" << R->getName() << "_out" << postfix;
    }
    Out<<";\n";

    Out << "end" << "\n";
}

// prevAddr is the bottom 3 bits of the previous address
void VerilogWriter::printPrevAddr(const RAM *R, std::string postfix) {
    Out << indent0 << "memory_controller_"<< R->getName() <<"_out" << postfix
        << " = 0;\n";
    Out << indent0 << "case(prevAddr" << postfix << ")\n";

    for (int i = 0; i < 8; i++) {
        int dataSize = 0;
        int prevRamOutLo = 0;
        int prevRamOutHi = 0;
        switch(i) {
            case 0:
                // long long
                dataSize = 64; break;
            case 1:
            case 2:
            case 3:
            case 4:
                // int
                dataSize = 32; break;
            case 5:
            case 6:
                // short
                dataSize = 16; break;
            case 7:
                // byte
                dataSize = 8; break;
            default:
                llvm_unreachable(0);
        }

        prevRamOutLo = i*8;
        prevRamOutHi = i*8 + dataSize;

        Out << indent0 << "\t" << i << ": " <<
            "memory_controller_"<< R->getName() <<"_out" << postfix << "[" << dataSize << "-1:0]" <<
            " = memory_controller_" << R->getName() << "_out_struct" << postfix << "[" << prevRamOutHi << 
            "-1:" << prevRamOutLo << "];\n";
    }
    Out << indent0 << "endcase\n";
}

void VerilogWriter::printAddrAlignmentCheck(std::string postfix) {

    //if( prevSize==0 ) prevSize_and = 3'b000
    //if( prevSize==1 ) prevSize_and = 3'b001
    //if( prevSize==2 ) prevSize_and = 3'b011
    //if( prevSize==3 ) prevSize_and = 3'b111
    //prevSize AND with last 3 bits of prevAddr to check the aligment   
    Out << indent0 << "prevSize" << postfix << 
        "_and[0] = prevSize" << postfix << "[1] | prevSize" << postfix << "[0];\n" <<
        indent0 << "prevSize" << postfix << "_and[1] = prevSize" << postfix << "[1];\n" <<
        indent0 << "prevSize" << postfix << "_and[2] = prevSize" << postfix << 
        "[1] & prevSize" << postfix << "[0];\n";

    Out << indent0 << "if ((prevAddr" << postfix << " & prevSize" << postfix << "_and) != 0 && memory_controller_enable" <<postfix << ")\n";
    Out << indent0 << "begin\n";
    Out << indent0 << "\t$display(\"Error: " <<
        "memory address not aligned to ram size!\");\n";
    Out << indent0 << "\t$finish;\n";
    Out << indent0 << "end\n";

}

void VerilogWriter::printTop(const Function * F) {

    for (Allocation::const_define_iterator i = alloc->define_begin(), e =
            alloc->define_end(); i != e; ++i) {
        const std::string name = i->first;
        const std::string value = i->second;
        const std::string comment = alloc->getDefineComment(name);
        if (!comment.empty()) {
            Out << "// " << comment << "\n";
        }

        Out << "`define " << name << " " << value << "\n";
    }


    // print top for hybrid flow
    if (LEGUP_CONFIG->numAccelerators() > 0) {

		printTopHybrid(F, alloc->getDataSize());
		return;
	}

    Out << "\n";
    Out << "// Turn off warning 'ignoring unsupported system task'\n";
    Out << "// altera message_off 10175\n";
    Out << "\n";

    Out << "module top\n" <<
    "\t(\n" <<
    "\t\tclk,\n";
    if (LEGUP_CONFIG->getParameterInt("MULTIPUMPING")) {
        Out << "\t\tclk2x,\n" <<
        "\t\tclk1x_follower,\n";
    }
    Out << "\t\treset,\n" <<
    "\t\tstart,\n" <<
    "\t\tfinish,\n" <<
    "\t\treturn_val\n" <<
    "\t);\n";

    Out << "input clk;\n";
    if (LEGUP_CONFIG->getParameterInt("MULTIPUMPING")) {
        Out << "input clk2x;\n";
        Out << "input clk1x_follower;\n";
    }
    Out << "input reset;\n";
    Out << "input start;\n";
    Out << "output wire finish;\n";
    Out << "output wire [31:0] return_val;\n";


    // instantiate memory controller
    printMemoryVariables(true);

    Out << "assign memory_controller_waitrequest = 0;\n\n";

	printMemoryInstance();


    // avalon

    // instantiate main
        Out << "main main_inst(" << "\n" <<
            "\t" << ".clk( clk )," << "\n" <<
            "\t" << ".clk2x( clk2x )," << "\n" <<
            "\t" << ".clk1x_follower( clk1x_follower )," << "\n" <<
            "\t" << ".reset( reset )," << "\n" <<
            "\t" << ".start( start )," << "\n" <<
            "\t" << ".finish( finish )," << "\n" <<
            "\t" << ".return_val( return_val )," << "\n" <<
            "\t" << ".memory_controller_address_a( memory_controller_address_a )," << "\n" <<
            "\t" << ".memory_controller_address_b( memory_controller_address_b )," << "\n" <<
            "\t" << ".memory_controller_enable_a( memory_controller_enable_a )," << "\n" <<
            "\t" << ".memory_controller_enable_b( memory_controller_enable_b )," << "\n" <<
            "\t" << ".memory_controller_write_enable_a( memory_controller_write_enable_a )," << "\n" <<
            "\t" << ".memory_controller_write_enable_b( memory_controller_write_enable_b )," << "\n" <<
            "\t" << ".memory_controller_waitrequest( memory_controller_waitrequest )," << "\n" <<
            "\t" << ".memory_controller_in_a( memory_controller_in_a )," << "\n"<<
            "\t" << ".memory_controller_in_b( memory_controller_in_b )," << "\n";
            
        if (alloc->usesGenericRAMs()){
            Out << "\t" << ".memory_controller_size_a( memory_controller_size_a )," << "\n";
            Out << "\t" << ".memory_controller_size_b( memory_controller_size_b )," << "\n";
        }
        
            Out << "\t" << ".memory_controller_out_a( memory_controller_out_a )," << "\n" ;
            Out << "\t" << ".memory_controller_out_b( memory_controller_out_b )" << "\n" <<
                ");\n";

        Out << "\n";
        Out << "endmodule\n";
}

void VerilogWriter::printTopHybrid(const Function *F, unsigned dataSize) {

	
	bool usesLocks = false; 
	bool usesBarriers = false; 
	bool usesOMP = false; 

	//const Function * const F2 = F;
	//this indicates whether you need any parallel APIs (locks, barriers, omp core)
	//if true, it will create another Avalon master 
	bool usesParallelAPI = alloc->usesParallelAPI(*F, usesLocks, usesBarriers, usesOMP);
	//this indicates whether this is a parallel function
	//if so, it will use polling instead of stalling
	//a parallel function does not always uses ParallelAPI, since a pthread with no locks/barriers will not use parallel API. 
	bool isParallel = LEGUP_CONFIG->isParallelAccel(*F);

	printMemTag(dataSize, usesLocks, usesBarriers, usesOMP);

	printAvalonInterface(F->getName(), usesParallelAPI);
	
	int AddressBusWidth = getAvalonBusWidth(F);

	printIODeclarations(AddressBusWidth, usesParallelAPI);

	std::vector<int> arg_bitwidth;

	bool return64 = printSignalDeclarations(F, arg_bitwidth, usesParallelAPI);
	
	int NumParams = F->arg_size();

	printAssignStatements(NumParams, return64, isParallel, usesParallelAPI, usesLocks, usesBarriers, usesOMP);

	printArgsReceivers(NumParams, arg_bitwidth);

	printStartDoneSignals();

	printMemorySignals(usesParallelAPI);

	bool voidtype = printReturnValSignals(return64, F, isParallel);

	if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
		printArbiterInstance(usesParallelAPI);
	}

	printMemoryInstance();

	printAccelInstance(F, NumParams, voidtype);

	printModelsimSignals(voidtype);

}

std::string VerilogWriter::parseMIPSdisassembly(const char * disassembly, std::string varName) {

	std::string var1, var2, var_addr;
	std::ifstream globals;
	varName.insert(0, "<"); //making into the format in disassembly
	varName.append(">:");

	globals.open(disassembly); //parse mips diassembly to get global variable addresses
	assert (globals);
	while (globals >> var1) { 
		if (var1 == varName) {		
			var_addr = var2;
			break; 
		}
		else {
			globals >> var2;
			if (var2 == varName) {
				var_addr = var1;
				break;
			}
		}
	}
	globals.close();
	return var_addr;
}

void VerilogWriter::printHybridTags(bool usesLocks, bool usesBarriers, bool usesOMP) {
	Out << "`define CPU_ACCEL_PORT 32'h01000000" << "\n";
	if (usesLocks) {
		Out << "`define MUTEX_ADDR 32'hC5000020" << "\n";
		Out << "`define MUTEX_ADDR2 32'hC5000024" << "\n";
	}

	if (usesBarriers) {
		Out << "`define BARRIER_ADDR 32'hC5000040" << "\n";
		Out << "`define BARRIER_ADDR2 32'hC5000044" << "\n";
	}

	if (usesOMP) {
		Out << "`define OMP_ADDR 32'hC5000000" << "\n";
		Out << "`define OMP_ADDR2 32'hC5000004" << "\n";
	}
}

void VerilogWriter::printGlobalTags(const RAM *R) {

	// PCIe flow shouldn't be sharing globals with the processor...
	if (LEGUP_CONFIG->isPCIeFlow()) {
		return;
	}

	const char * dis = NULL;
	std::string Disassembly;
	Disassembly = std::getenv ("LEGUP_ACCELERATOR_FILENAME");
	Disassembly += ".src";
	dis = Disassembly.c_str();
	std::string var_name, var_addr;
	var_name = R->getName();
	var_addr = parseMIPSdisassembly(dis, var_name);
	//checking if address for the global variable was parsed
	if (var_addr == "") {
		if (std::string::npos != var_name.find("_var")) {
			//in this case we search again with _var removed
			size_t pos = var_name.find("_var");
			std::string var;
			var.assign(var_name, 0, pos);
			var_addr = parseMIPSdisassembly(dis, var);
			//if the address still cannot be parsed, then quit
			if (var_addr == "") {
				errs() << "\nError: Address for global variable " << var_name << " not found in MIPS disassembly!\n\n";
				assert(0);
			}
		} else {
			errs() << "\nError: Address for global variable " << var_name << " not found in MIPS disassembly!\n\n";
			assert(0);
		}
	}
	var_name.insert(0, "TAG_g_"); //make it into the proper TAG format
	var_name.append("_a");
	var_addr.insert(0, "32'h");
	Out << "`define " << var_name << " " << var_addr << "\n";
}

void VerilogWriter::printLocalTags(const RAM *R, unsigned dataSize, unsigned &tag) {

   	if (LEGUP_CONFIG->getDeviceFamily() == "CycloneII" && tag > 511) { // the biggest tag (number of local RAMs) supported for Cyclone II is 511								
		assert(0 && "Too many local memories! The largest tag supported is 511!\n");
	} else if (LEGUP_CONFIG->getDeviceFamily() == "StratixIV" && tag > 127) { // the biggest tag (number of local RAMs) supported for Stratix IV is 127
		assert(0 && "Too many local memories! The largest tag supported is 127!\n");
	}
    Out << "`define " << R->getTag() << " `MEMORY_CONTROLLER_TAG_SIZE'd" << tag << "\n";
    tag++;
    dataSize = std::max(dataSize, R->getDataWidth());
    Out << "`define " << R->getTagAddrName() << " " << R->getTagAddr() << "\n";
}

void VerilogWriter::printMemTag(unsigned dataSize, bool usesLocks, bool usesBarriers, bool usesOMP) {

	//since two tags are reserved for NULL and processor
    unsigned tag = 2;
//	int size = dataSize;
	const RAM *R;

	//to print out memory controller tags
	for (Allocation::const_ram_iterator i = alloc->ram_begin(), e = alloc->ram_end(); i != e; ++i) {
	    R = *i;
	    Out << "// " << getValueStr(R->getValue()) << '\n';
	    if (stripRAM(R->getValue())) { 	//print memory address only if its a global variable which is not a constant
			printGlobalTags(R);
		} 
		else {
			printLocalTags(R, dataSize, tag);
		}
	}

	printHybridTags(usesLocks, usesBarriers, usesOMP);
}

void VerilogWriter::printAvalonInterface(std::string ModuleName, bool usesParallelAPI) {

	stripInvalidCharacters(ModuleName);
	Out << "`timescale 1 ns / 1 ns" << "\n";
	Out << "module " << ModuleName << "_top\n" << 
	"\t(\n" <<
	"\t\tcsi_clockreset_clk,\n" <<
	"\t\tcsi_clockreset_reset,\n" <<
	"\t\t//Slave interface to talk to processor\n" <<
	"\t\t//Inputs\n" <<
	"\t\tavs_s1_address,\n" <<
	"\t\tavs_s1_read,\n" <<
	"\t\tavs_s1_write,\n" <<
	"\t\tavs_s1_writedata,\n" <<
	"\t\t//Outputs\n" <<
	"\t\t//Memory\n" <<
	"\t\tavs_s1_readdata,\n" <<
	"\t\tavm_ACCEL_readdata,\n" <<
	"\t\tavm_ACCEL_waitrequest,\n" <<
	"\t\tavm_ACCEL_address,\n" <<
	"\t\tavm_ACCEL_writedata,\n" <<
	"\t\tavm_ACCEL_write,\n" <<
	"\t\tavm_ACCEL_read";
	if (usesParallelAPI) {
		Out << ",\n"
		"\t\t//API\n" <<
		"\t\tavm_API_readdata,\n" <<
		"\t\tavm_API_waitrequest,\n" <<
		"\t\tavm_API_address,\n" <<
		"\t\tavm_API_writedata,\n" <<
		"\t\tavm_API_write,\n" <<
		"\t\tavm_API_read\n";
	}

	Out << "\t);\n";
}

	
int VerilogWriter::getAvalonBusWidth(const Function * F) {

	int NumArg32bit = 0;
	int NumArg64bit = 0;
    for (Function::const_arg_iterator it = F->arg_begin(), e = F->arg_end(); it
            != e; ++it) { //get number of 32 bit and 64 bit arguments
		if (const IntegerType *ITy = dyn_cast<IntegerType>(it->getType())) {
			if (ITy->getBitWidth() == 64)
			{
				NumArg64bit++;
			}
			else if (ITy->getBitWidth() <= 32)
			{
				NumArg32bit++;
			}
		}
		else if (it->getType()->isFloatTy()) {//if argument is a float
			NumArg32bit++;
		}
		else if (it->getType()->isDoubleTy()) {//if argument is a double
			NumArg64bit++;
		}
		else if (dyn_cast<PointerType>(it->getType())) {//if argument is a pointer
			NumArg32bit++;
		}
		else if (dyn_cast<ArrayType>(it->getType())) { //if argument is an array
			NumArg32bit++;
		}
		else {
			assert(0 && "Unsupported Argument for Accelerator\n");	
  		}
	}
	return (ceil(log (NumArg32bit+2*NumArg64bit+3) / log (2))); //define avalon slave address bus width according to number of arguments
}

void VerilogWriter::printIODeclarations(int AddressBusWidth, bool usesParallelAPI) {
	Out << "\ninput csi_clockreset_clk;\n" <<
	"input csi_clockreset_reset;\n" <<

	
	"input ["<< AddressBusWidth-1 << ":0]avs_s1_address;\n" <<
	"input avs_s1_read;\n" <<
	"input avs_s1_write;\n" <<

	"input [31:0] avs_s1_writedata;\n"<<
	"output reg [31:0] avs_s1_readdata;\n"<<

	"input [127:0] avm_ACCEL_readdata;\n"<<
	"output [127:0] avm_ACCEL_writedata;\n"<<
	"input avm_ACCEL_waitrequest;\n"<<

	"output wire [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] avm_ACCEL_address;\n"<<
	"output wire avm_ACCEL_write;\n"<<
	"output wire avm_ACCEL_read;\n";

	if (usesParallelAPI) {
		Out <<"input [31:0] avm_API_readdata;\n"<<
		"input avm_API_waitrequest;\n"<<
		"output [31:0] avm_API_writedata;\n"<<
		"output wire [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] avm_API_address;\n"<<
		"output wire avm_API_write;\n"<<
		"output wire avm_API_read;\n";
	}
}

bool VerilogWriter::printSignalDeclarations(const Function * F,
        std::vector<int> &arg_bitwidth, bool usesParallelAPI) {


	const Type* ret = F->getReturnType();
	bool return64 = false;
	Out << "wire finish;\n";
	if (!(ret->isVoidTy())) {
		if (ret->isPointerTy()) {
			Out << "wire [31:0] return_val_wire;\n";
		    Out << "reg [31:0] return_val;\n";
		} else {
		    unsigned bitwidth = getBitWidth(ret);
			if (bitwidth == 64) {
				Out << "wire read_data_asserted_hi;\n";	
				return64 = true;
			}

		    Out << "wire [" << bitwidth - 1 << ":0] return_val_wire;\n";
		    Out << "reg [" << bitwidth - 1 << ":0] return_val;\n";
		}
	}

	Out << "wire clk;\n"<<
	"wire reset;\n"<<
	"wire start;\n"<<
	"wire memory_controller_waitrequest;\n"<<
	"reg start_reg;\n"<<
	"reg finish_reg;\n"<<
	"reg done;\n"<<
	"wire read_data_asserted_lo;\n"<<
	"wire read_status_asserted;\n"<<
	"reg [1:0] memory_controller_state;\n"<<

	"localparam MEMORY_ACCESS_LATENCY = 2;\n";
	printMemorySignalDeclarations(usesParallelAPI, "_a");
	if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
		printMemorySignalDeclarations(usesParallelAPI, "_b");
	}

	Out << "localparam stateIDLE = 2'b00;\n"<<
	"localparam stateFIRST = 2'b01;\n"<<
	"localparam stateSECOND = 2'b10;\n";

	printArgumentSignalDeclarations(F, arg_bitwidth);
	return return64;
}

void VerilogWriter::printArgumentSignalDeclarations(const Function * F, std::vector<int> &arg_bitwidth) {

	int NumParams = F->arg_size();
	int argIdx = 1;
	int data_size;
	if (NumParams > 0 ) {

		for (Function::const_arg_iterator it = F->arg_begin(), e = F->arg_end(); it != e; ++it) {
			data_size = 31;
			if (const IntegerType *ITy = dyn_cast<IntegerType>(it->getType())) {
				if (ITy->getBitWidth() == 64) //if data type is long long
					data_size = 63;
			} else if (it->getType()->isDoubleTy()) {
				data_size = 63;
			}
			arg_bitwidth.push_back(data_size);
			Out << "reg [" << data_size << ":0]ARG" << argIdx << ";\n";
			Out << "reg ARG" << argIdx << "_ready;\n";
			argIdx++;
		}
		Out << "wire parameter_ready;\n\n";
	}
}

void VerilogWriter::printMemorySignalDeclarations(bool usesParallelAPI, std::string postfix) {

	Out << "wire [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] memory_address" << postfix << ";\n"<<
 	"reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] memory_address_reg" << postfix << ";\n";
	if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
		Out << "reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] memory_controller_address" << postfix << ";\n";
	} else {
		Out << "wire [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] memory_controller_address" << postfix << ";\n";
	}
	Out << "wire memory_controller_enable" << postfix << ";\n"<<
	"wire memory_controller_write_enable" << postfix << ";\n"<<
	"wire [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_in" << postfix << ";\n"<<
	"wire [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_out" << postfix << ";\n"<<
	"wire [1:0] memory_controller_size" << postfix << ";\n"<<

	"reg [`MEMORY_CONTROLLER_DATA_SIZE-1:0] sdram_data" << postfix << ";\n"<<
	"reg [`MEMORY_CONTROLLER_DATA_SIZE-1:0] sdram_data_reg" << postfix << ";\n"<<
	"reg [`MEMORY_CONTROLLER_DATA_SIZE-1:0] sdram_data_reg_reg" << postfix << ";\n"<<

	"reg [`MEMORY_CONTROLLER_DATA_SIZE-1:0] data_from_memory" << postfix << ";\n"<<
	"wire [`MEMORY_CONTROLLER_DATA_SIZE-1:0] data_to_memory" << postfix << ";\n"<<
	"reg [`MEMORY_CONTROLLER_DATA_SIZE-1:0] data_from_memory_reg" << postfix << ";\n"<<

	"reg sdram_data_ready" << postfix << ";\n"<<
	"wire flag_to_sdram" << postfix << ";\n"<<
	"wire enable" << postfix << ";\n"<<
	"wire write_enable" << postfix << ";\n"<<
	"wire gnt" << postfix << ";\n";

	if (usesParallelAPI) {
		Out << "wire api_address" << postfix << ";\n"<<
		"reg [`MEMORY_CONTROLLER_DATA_SIZE-1:0] api_data" << postfix << ";\n"<<
		"reg [`MEMORY_CONTROLLER_DATA_SIZE-1:0] api_data_reg" << postfix << ";\n";
	}

	Out << "//shift register to indicate whether to take data from main memory or block RAM\n"<<
	"reg [MEMORY_ACCESS_LATENCY - 1:0] SDRAM_shiftreg" << postfix << ";\n"<<
	"reg [MEMORY_ACCESS_LATENCY - 1:0] BRAM_shiftreg" << postfix << ";\n"<<
	"reg [MEMORY_ACCESS_LATENCY - 1:0] SDRAM_shiftreg_changed" << postfix << ";\n"<<
	"reg [MEMORY_ACCESS_LATENCY - 1:0] BRAM_shiftreg_changed" << postfix << ";\n";
	if (usesParallelAPI) {
		Out << "reg [MEMORY_ACCESS_LATENCY - 1:0] API_shiftreg" << postfix << ";\n"<<
		"reg [MEMORY_ACCESS_LATENCY - 1:0] API_shiftreg_changed" << postfix << ";\n";
	}

	if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
		Out << "reg [MEMORY_ACCESS_LATENCY - 1:0] doubleSDRAM_shiftreg" << postfix << ";\n"<<
		"reg [MEMORY_ACCESS_LATENCY - 1:0] doubleSDRAM_shiftreg_changed" << postfix << ";\n";
	}
}

void VerilogWriter::printACCELassignStatements(bool isParallel, bool usesParallelAPI) {

	//when stalling
	Out << "assign avm_ACCEL_address = `CPU_ACCEL_PORT;\n";

	//when polling
	if (isParallel) {
		if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
			Out << "assign avm_ACCEL_write = (gnt_a & write_enable_a";
			if (usesParallelAPI) { Out << "& !api_address_a"; }
			Out << ") | (gnt_b & write_enable_b";
			if (usesParallelAPI) { Out << "& !api_address_b"; }
			Out << ");\n" <<
			"assign avm_ACCEL_read = (gnt_a & enable_a & !write_enable_a";
			if (usesParallelAPI) { Out << "& !api_address_a"; }
			Out << ") | (gnt_b & enable_b & !write_enable_b";
			if (usesParallelAPI) { Out << "& !api_address_b"; }
			Out << ");";
		} else {
			Out << "assign avm_ACCEL_write = enable_a & write_enable_a & flag_to_sdram_a;\n" <<
			"assign avm_ACCEL_read = enable_a & ~write_enable_a & flag_to_sdram_a;";
		}
	//when stalling
	} else {
		if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
			Out << "assign avm_ACCEL_write = (gnt_a & write_enable_a) | (gnt_b & write_enable_b) | (start | finish);\n" <<
			"assign avm_ACCEL_read = (gnt_a & enable_a & !write_enable_a) | (gnt_b & enable_b & !write_enable_b);\n";
		} else {
			Out << "assign avm_ACCEL_write = enable_a & write_enable_a & flag_to_sdram_a | start |finish;\n" <<
			"assign avm_ACCEL_read = enable_a & ~write_enable_a & flag_to_sdram_a;\n";
		}
	}

	if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
		Out << "//send address portion\n"<<
		"assign avm_ACCEL_writedata[31:0] = gnt_a? memory_address_a : memory_address_b;\n"<<
		"//send data portion\n"<<
		"assign avm_ACCEL_writedata[95:32] = gnt_a? data_to_memory_a : data_to_memory_b;\n"<<
		"//send size portion\n"<<
		"assign avm_ACCEL_writedata[96] = gnt_a? (memory_controller_size_a == 2'b00) : (memory_controller_size_b == 2'b00); //8-bit\n"<<
		"assign avm_ACCEL_writedata[97] = gnt_a? (memory_controller_size_a == 2'b01) : (memory_controller_size_b == 2'b01); //16-bit\n"<<
		"assign avm_ACCEL_writedata[98] = gnt_a? (memory_controller_size_a == 2'b11) : (memory_controller_size_b == 2'b11); //64-bit\n";
	} else {
		Out << "//send address portion\n"<<
		"assign avm_ACCEL_writedata[31:0] = memory_address_a;\n"<<
		"//send data portion\n"<<
		"assign avm_ACCEL_writedata[95:32] = data_to_memory_a;\n"<<
		"//send size portion\n"<<
		"assign avm_ACCEL_writedata[96] = (memory_controller_size_a == 2'b00); //8-bit\n"<<
		"assign avm_ACCEL_writedata[97] = (memory_controller_size_a == 2'b01); //16-bit\n"<<
		"assign avm_ACCEL_writedata[98] = (memory_controller_size_a == 2'b11); //64-bit\n";
	}
	
	Out << "//send flush signal (unused for accelerator)\n"<<
	"assign avm_ACCEL_writedata[99] = 1'b0;\n";

	if (!isParallel) {
		Out << "//to stall processor\n"<<
		"assign avm_ACCEL_writedata[100] = start;\n"<<
		"//to unstall processor\n"<<
		"assign avm_ACCEL_writedata[101] = finish;\n";
	} else {
		Out << "assign avm_ACCEL_writedata[100] = 1'b0;\n"<<
		"assign avm_ACCEL_writedata[101] = 1'b0;\n";
	}
	
	Out <<"assign avm_ACCEL_writedata[127:102] = 28'd0;\n";
}

void VerilogWriter::printMemoryAssignStatements(int NumParams, bool return64, bool isParallel, bool usesParallelAPI) {

	if (!LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
		Out << "assign gnt_a = enable_a;\n";
	}

	Out << "assign memory_controller_waitrequest = avm_ACCEL_waitrequest";
	if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
		Out << " || (memory_controller_state == stateFIRST)";
	}
	if (usesParallelAPI) {
		Out << " || avm_API_waitrequest";
	}
	Out << ";\n";

	printMemoryControllerAssignStatements(usesParallelAPI, "_a");

	if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) { 
		printMemoryControllerAssignStatements(usesParallelAPI, "_b");
	}

	Out << "assign start = (avs_s1_address == 2) & (avs_s1_writedata[31:0] == 1) & (avs_s1_write == 1'b1)";
	
	if (NumParams > 0) {
		Out << " & parameter_ready";
 	}
	Out << ";\n";

	Out << "assign read_data_asserted_lo = (avs_s1_address == 0) & (avs_s1_read == 1'b1) & (done == 1'b1);\n";
	if (return64) {
		Out <<"assign read_data_asserted_hi = (avs_s1_address == 1) & (avs_s1_read == 1'b1) & (done == 1'b1);\n";
	}

	printoffChipMemoryFlags("_a");
	if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
		printoffChipMemoryFlags("_b");
	}

	//for polling
	if (isParallel) {
		Out <<"assign read_status_asserted = (avs_s1_address == 2) & (avs_s1_read == 1'b1) & (done == 1'b1);\n";
	}
}

void VerilogWriter::printoffChipMemoryFlags(std::string postfix) {
   	if (LEGUP_CONFIG->getDeviceFamily() == "CycloneII") {
		Out << "assign flag_to_sdram" << postfix << " = (memory_address" << postfix << "[31:23] == `TAG_PROCESSOR);\n";
	} else if (LEGUP_CONFIG->getDeviceFamily() == "StratixIV") {
		Out << "assign flag_to_sdram" << postfix << " = memory_address" << postfix << "[30];\n";
	} else {
	        llvm_unreachable("Unrecognized device family!");
	}
}

void VerilogWriter::printMemoryControllerAssignStatements(bool usesParallelAPI, std::string postfix) {
	if (!LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
		Out << "assign memory_controller_address" << postfix << " = memory_address" << postfix << ";\n";
	}

	Out << "assign memory_controller_enable" << postfix << " = enable" << postfix << " && !flag_to_sdram" << postfix;
	if (usesParallelAPI) { Out << " && !api_address" << postfix; }
	Out << ";\n";

	Out << "assign memory_controller_write_enable" << postfix << " = write_enable" << postfix << " && !flag_to_sdram" << postfix;
	if (usesParallelAPI) { Out << " && !api_address" << postfix; }
	Out << ";\n";
	Out << "assign memory_controller_in" << postfix << " = data_to_memory" << postfix << ";\n";
}

void VerilogWriter::printAPIAssignStatements(bool usesLocks, bool usesBarriers, bool usesOMP) {

	Out <<"assign api_address_a = 1'b0";

	if (usesLocks) {
		Out << " || (memory_address_a == `MUTEX_ADDR) || (memory_address_a == `MUTEX_ADDR2)";
	} 
	if (usesBarriers) {
		Out << " || (memory_address_a == `BARRIER_ADDR) || (memory_address_a == `BARRIER_ADDR2)";
	}
	if (usesOMP) {
		Out << " || (memory_address_a == `OMP_ADDR) || (memory_address_a == `OMP_ADDR2)";
	}
	Out << ";\n";

	if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {

		Out <<"assign api_address_b = 1'b0";

		if (usesLocks) {
			Out << " || (memory_address_b == `MUTEX_ADDR) || (memory_address_b == `MUTEX_ADDR2)";
		} 
		if (usesBarriers) {
			Out << " || (memory_address_b == `BARRIER_ADDR) || (memory_address_b == `BARRIER_ADDR2)";
		}
		if (usesOMP) {
			Out << " || (memory_address_b == `OMP_ADDR) || (memory_address_b == `OMP_ADDR2)";
		}
		Out << ";\n";

		Out << "assign avm_API_writedata = gnt_a? data_to_memory_a : data_to_memory_b;\n"<<
		"assign avm_API_address = gnt_a? memory_address_a : memory_address_b;\n"<<
		"assign avm_API_write = (gnt_a & write_enable_a & api_address_a) | (gnt_b & write_enable_b & api_address_b);\n"<<
		"assign avm_API_read = (gnt_a & enable_a & !write_enable_a & api_address_a) | (gnt_b & enable_b & !write_enable_b & api_address_b);\n";
	} else {
		Out << "assign avm_API_writedata = data_to_memory_a;\n"<<
		"assign avm_API_address = memory_address_a;\n"<<
		"assign avm_API_write = enable_a & write_enable_a & api_address_a;\n"<<
		"assign avm_API_read = enable_a & ~write_enable_a & api_address_a;\n";
	}
}

void VerilogWriter::printAssignStatements(int NumParams, bool return64, bool isParallel, bool usesParallelAPI, bool usesLocks, bool usesBarriers, bool usesOMP) {

	if (NumParams > 0 ) {
		Out << "assign parameter_ready = ";
		for (int i=1; i<=NumParams; i++) {
			Out << "ARG" << i << "_ready";
			if (i==NumParams) {
				continue;
			}
			Out << " && ";
		}		

		Out << ";\n";
	}

	Out << "assign clk = csi_clockreset_clk;\n"<<
	"assign reset = csi_clockreset_reset;\n";

	printACCELassignStatements(isParallel, usesParallelAPI);

	printMemoryAssignStatements(NumParams, return64, isParallel, usesParallelAPI);

	if (usesParallelAPI) {
		printAPIAssignStatements(usesLocks, usesBarriers, usesOMP);
	}
}

void VerilogWriter::printArgsReceivers(int NumParams, const std::vector<int>
        &arg_bitwidth) {

	int argIdx = 1;
	int addrIdx = 3;
	int data_size;
	for (int i=0; i<NumParams; i++) {
		data_size = arg_bitwidth[i];
		if (data_size == 31) {
			Out << "\nalways @(posedge clk)\n"<<
			"begin\n"<<
			"\tif (start || reset)\n"<<
			"\tbegin\n"<<
			"\t\tARG"<< argIdx << "_ready <= 1'b0;\n"<<
			"\tend\n"<<
			"\telse if ((avs_s1_address == " << addrIdx << ") & (avs_s1_write))\n"<<
			"\tbegin\n"<<
			"\t\tARG"<< argIdx << "[31:0] <= avs_s1_writedata[31:0];\n"<<
			"\t\tARG"<< argIdx << "_ready <= 1'b1;\n"<<
			"\tend\n"<<
			"end\n";
			addrIdx++;
			argIdx++;
		}
		else if (data_size == 63) {
			Out << "\nalways @(posedge clk)\n"<<
			"begin\n"<<
			"\tif ((avs_s1_address == " << addrIdx << ") & (avs_s1_write))\n"<<
			"\tbegin\n"<<
			"\t\tARG"<< argIdx << "[31:0] <= avs_s1_writedata[31:0];\n"<<
			"\tend\n"<<
			"end\n";
			addrIdx++;

			Out << "\nalways @(posedge clk)\n"<<
			"begin\n"<<
			"\tif (start || reset)\n"<<
			"\tbegin\n"<<
			"\t\tARG"<< argIdx << "_ready <= 1'b0;\n"<<
			"\tend\n"<<
			"\telse if ((avs_s1_address == " << addrIdx << ") & (avs_s1_write))\n"<<
			"\tbegin\n"<<
			"\t\tARG"<< argIdx << "[63:32] <= avs_s1_writedata[31:0];\n"<<
			"\t\tARG"<< argIdx << "_ready <= 1'b1;\n"<<
			"\tend\n"<<
			"end\n";
			addrIdx++;
			argIdx++;
		}
		else { 
			assert(0 && "Parameter data bitwidth undefined!\n");
		}
	}
}

void VerilogWriter::printStartDoneSignals() {

	Out << "\nalways @(posedge clk)\n"<<
	"begin\n"<<
	"\tstart_reg <= start;\n"<<
	"\tfinish_reg <= finish;\n"<<
	"end\n";

	Out << "\n"<<
	"always @(posedge clk)\n"<<
	"begin\n"<<
	"\tif (reset || start)\n"<<
	"\t\tdone <= 1'b0;\n"<<
	"\telse if (finish)\n"<<
	"\t\tdone <= 1'b1;\n"<<
	"end\n"<<
	"\n";
}


void VerilogWriter::printMemorySignals(bool usesParallelAPI) {

	Out << "always @(posedge clk)\n"<<
	"begin\n"<<
	"\tif (!memory_controller_waitrequest)\n"<<
	"\tbegin\n"<<
	"\t\tmemory_address_reg_a <= memory_address_a;\n"<<
	"\t\tmemory_address_reg_b <= memory_address_b;\n"<<
	"\tend\n"<<
	"end\n\n";

	printMemoryDataReadySignals(usesParallelAPI);
	printMemoryShiftRegisters(usesParallelAPI, "_a");
	if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
		printMemoryShiftRegisters(usesParallelAPI, "_b");
	}
	printMemoryDataSignals(usesParallelAPI);
}

void VerilogWriter::printMemoryDataReadySignals(bool usesParallelAPI) {

	if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
		Out << "always @(*)\n"<<
		"begin\n"<<
		"\tsdram_data_ready_a <= gnt_a & !avm_ACCEL_waitrequest";
		if (usesParallelAPI) { Out << "& !api_address_a"; }
		Out <<";\n"<<
		"end\n\n"<<

		"always @(*)\n"<<
		"begin\n"<<
		"\tsdram_data_ready_b <= gnt_b & !avm_ACCEL_waitrequest";
		if (usesParallelAPI) { Out << "& !api_address_b"; }
		Out << ";\n"<<
		"end\n\n";
	} else {
		Out << "always @(*)\n"<<
	//	Out << "always @(posedge clk)\n"<<
		"begin\n"<<
		"\tsdram_data_ready_a <= avm_ACCEL_read & flag_to_sdram_a & !avm_ACCEL_waitrequest;\n"<<
		"end\n\n";
	}
}

void VerilogWriter::printMemoryDataSignals(bool usesParallelAPI) {

	printMemoryDataReceivers(usesParallelAPI, "_a");
	if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
		printMemoryDataReceivers(usesParallelAPI, "_b");
		printMemoryStateMachine(usesParallelAPI);
	}
}

void VerilogWriter::printMemoryStateMachine(bool usesParallelAPI) {
	//print memory controller state machine for 2 Avalon memory accesses per cycle
	Out << "always @(posedge clk)\n"<<
	"begin\n"<<
	"\tif (reset) begin\n"<<
	"\t\tmemory_controller_state <= stateIDLE;\n"<<
	"\tend else begin\n"<<
	"\t\tcase (memory_controller_state)\n"<<
	"\t\t\tstateIDLE: begin\n"<<
	"\t\t\t\tif (flag_to_sdram_a && flag_to_sdram_b";
	if (usesParallelAPI) {
		Out << " || api_address_a && api_address_b";
	}
	Out << ")\n"<<
	"\t\t\t\t\tmemory_controller_state <= stateFIRST;\n"<<
	"\t\t\tend\n"<<
	"\t\t\tstateFIRST: begin\n"<<
	"\t\t\t\tif (!avm_ACCEL_waitrequest)\n"<<
	"\t\t\t\t\tmemory_controller_state <= stateSECOND;\n"<<
	"\t\t\tend\n"<<
	"\t\t\tstateSECOND: begin\n"<<
	"\t\t\t\tif (!avm_ACCEL_waitrequest)\n"<<
	"\t\t\t\t\tmemory_controller_state <= stateIDLE;\n"<<
	"\t\t\tend\n"<<
	"\t\tendcase\n"<<
	"\tend\n"<<
	"end\n";
}

void VerilogWriter::printMemoryDataReceivers(bool usesParallelAPI, std::string postfix) {

	Out << "\nalways @(posedge clk)\n"<<
	"begin\n"<<
	"\tif (sdram_data_ready" << postfix << ")\n"<<
	"\t\tsdram_data" << postfix << " <= avm_ACCEL_readdata[63:0];\n"<<
	"end\n\n";

	if (usesParallelAPI) {
		Out << "\nalways @(posedge clk)\n"<<
		"begin\n"<<
		"\tif (avm_API_read && gnt_a && api_address" << postfix << ")\n"<<
		"\t\tapi_data" << postfix << " <= avm_API_readdata;\n"<<
		"end\n";

		Out << "\nalways @(posedge clk)\n"<<
		"begin\n"<<
		"\tapi_data_reg" << postfix << " <= api_data" << postfix << ";\n"<<
		"end\n";
	}

	Out << "always @(*)\n"<<
	"begin\n"<<
	"\tdata_from_memory" << postfix << " = data_from_memory_reg" << postfix << ";\n"<<
	"\tbegin\n"<<
	"\tif (SDRAM_shiftreg_changed" << postfix << " || BRAM_shiftreg_changed" << postfix;
	if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) { Out << " || doubleSDRAM_shiftreg_changed" << postfix; }
	if (usesParallelAPI) { Out << " || API_shiftreg_changed_a"; }
	Out << ")\n";
	if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
		Out << "\t\tif (doubleSDRAM_shiftreg" << postfix << "[MEMORY_ACCESS_LATENCY - 1] == 1'b1)\n"<<
		"\t\t\tdata_from_memory" << postfix << " = sdram_data_reg_reg" << postfix << ";\n";
	}
	Out << "\t\tif (SDRAM_shiftreg" << postfix << "[MEMORY_ACCESS_LATENCY - 1] == 1'b1)\n"<<
	"\t\t\tdata_from_memory" << postfix << " = sdram_data_reg" << postfix << ";\n"<<
	"\t\telse if (BRAM_shiftreg" << postfix << "[MEMORY_ACCESS_LATENCY - 1] == 1'b1)\n"<<
	"\t\t\tdata_from_memory" << postfix << " = memory_controller_out" << postfix << ";\n";
	if (usesParallelAPI) {
		Out << "\t\telse if (API_shiftreg" << postfix << "[MEMORY_ACCESS_LATENCY - 1] == 1'b1)\n"<<
		"\t\t\tdata_from_memory" << postfix << " = api_data_reg" << postfix << ";\n";
	}
	Out << "\tend\n"<<
	"end\n\n";
	Out << "always @(posedge clk)\n"<<
	"begin\n"<<
	"\tdata_from_memory_reg" << postfix << " <= data_from_memory" << postfix << ";\n";
	Out << "end\n\n"<<

	"always @(posedge clk)\n"<<
	"begin\n"<<
	"\tif (!memory_controller_waitrequest)\n"<<
	"\t\tsdram_data_reg" << postfix << " <= sdram_data" << postfix << ";\n"<<
	"end\n\n";

	if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
		Out << "always @(posedge clk)\n"<<
		"begin\n"<<
		"\tif (!memory_controller_waitrequest)\n"<<
		"\t\tsdram_data_reg_reg" << postfix << " <= sdram_data_reg" << postfix << ";\n"<<
		"end\n\n";

		Out << "always @(*)\n"<<
		"begin\n"<<
		"\tif (memory_controller_waitrequest)\n"<<  
		"\tbegin\n"<<
		"\t\tmemory_controller_address" << postfix << " = memory_address_reg" << postfix << ";\n"<<
		"\tend\n"<<
		"\telse\n"<<
		"\tbegin\n"<<
		"\t\tmemory_controller_address" << postfix << " = memory_address" << postfix << ";\n"<<
		"\tend\n"<<
		"end\n\n";
	}
}

void VerilogWriter::printMemoryShiftRegisters(bool usesParallelAPI, std::string postfix) {

	Out << "always @(posedge clk)\n"<<
	"begin\n"<<
	"\tSDRAM_shiftreg_changed" << postfix << " <= 1'b0;\n"<<
	"\tif (!memory_controller_waitrequest)\n"<<
	"\tbegin\n"<<
	"\t\tSDRAM_shiftreg_changed" << postfix << " <= 1'b1;\n"<<
	"\t\tSDRAM_shiftreg" << postfix << " <= SDRAM_shiftreg" << postfix << " << 1;\n"<<
	"\t\tif (avm_ACCEL_read";
	if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) { Out << " && gnt" << postfix; }
	if (usesParallelAPI) { Out << " && !api_address" << postfix; }

	Out << ")\n"<<
	"\t\t\tSDRAM_shiftreg" << postfix << "[0] <= 1'b1;\n"<<
	"\t\telse\n"<<
	"\t\t\tSDRAM_shiftreg" << postfix << "[0] <= 1'b0;\n"<<
	"\tend\n"<<
	"end\n\n"<<

	"always @(posedge clk)\n"<<
	"begin\n"<<
	"\tBRAM_shiftreg_changed" << postfix << " <= 1'b0;\n"<<
	"\tif (!memory_controller_waitrequest)\n"<<
	"\tbegin\n"<<
	"\t\tBRAM_shiftreg_changed" << postfix << " <= 1'b1;\n"<<
	"\t\tBRAM_shiftreg" << postfix << " <= BRAM_shiftreg" << postfix << " << 1;\n"<<
	"\t\tif (memory_controller_enable" << postfix << " && !memory_controller_write_enable" << postfix;
	Out << ")\n"<<
	"\t\t\tBRAM_shiftreg" << postfix << "[0] <= 1'b1;\n"<<
	"\t\telse\n"<<
	"\t\t\tBRAM_shiftreg" << postfix << "[0] <= 1'b0;\n"<<
	"\tend\n"<<
	"end\n\n";

	if (usesParallelAPI) {
		Out << "always @(posedge clk)\n"<<
		"begin\n"<<
		"\tAPI_shiftreg_changed" << postfix << " <= 1'b0;\n"<<
		"\tif (!memory_controller_waitrequest)\n"<<
		"\tbegin\n"<<
		"\tAPI_shiftreg_changed" << postfix << " <= 1'b1;\n"<<
		"\t\tAPI_shiftreg" << postfix << " <= API_shiftreg" << postfix << " << 1;\n"<<
		"\t\tif (avm_API_read && gnt" << postfix << " && api_address" << postfix << ")\n"<<
		"\t\t\tAPI_shiftreg" << postfix << "[0] <= 1'b1;\n"<<
		"\t\telse\n"<<
		"\t\t\tAPI_shiftreg" << postfix << "[0] <= 1'b0;\n"<<
		"\tend\n"<<
		"end\n\n";
	}

	if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
		Out << "always @(posedge clk)\n"<<
		"begin\n"<<
		"\tdoubleSDRAM_shiftreg_changed" << postfix << " <= 1'b0;\n"<<
		"\tif (!memory_controller_waitrequest)\n"<<
		"\tbegin\n"<<
		"\t\tdoubleSDRAM_shiftreg_changed" << postfix << " <= 1'b1;\n"<<
		"\t\tdoubleSDRAM_shiftreg" << postfix << " <= doubleSDRAM_shiftreg" << postfix << " << 1;\n"<<
		"\t\t//this means that the first memory access was from port 1, since it's in the second state when port 2 is being used\n"<<
		"\t\tif (memory_controller_state == stateSECOND && gnt";
		if (postfix == "_a") {
			Out << "_b";
		} else {
			Out << "_a";
		}
		Out << ")\n"<<
		"\t\t\tdoubleSDRAM_shiftreg" << postfix << "[0] <= 1'b1;\n"<<
		"\t\telse\n"<<
		"\t\t\tdoubleSDRAM_shiftreg" << postfix << "[0] <= 1'b0;\n"<<
		"\tend\n"<<
		"end\n\n";
	}
}

bool VerilogWriter::printReturnValSignals(bool return64, const Function * F, bool isParallel) {

	const Type* ret = F->getReturnType();
	//CPU reading from Accelerator
	bool voidtype = true;
	if (ret->getTypeID() != Type::VoidTyID) {
		voidtype = false;
	}
	
	if (!voidtype) {
		Out << "\n"<<
		"always @(posedge clk)\n"<<
		"begin\n"<<
		"\tif (finish)\n"<<
		"\t\treturn_val <= return_val_wire;\n"<<
		"end\n"<<
		"\n\n";
	}


	//If this is a parallel accelerator
	if (isParallel) {
		//print out always block for polling
		Out << "always @(*)\n"<<
		"begin\n";
		Out << "\tif (read_status_asserted) //for polling\n"<<
		"\t\tavs_s1_readdata <= 1;\n";
		//if this is not a void function
		if (!voidtype) {
			//print out signals to return data
			 if (return64) {
				Out << "\telse if (read_data_asserted_lo) //to return data\n"<<
				"\t\tavs_s1_readdata = return_val[31:0];\n";
				Out << "\telse if (read_data_asserted_hi)\n"<<
				"\t\tavs_s1_readdata = return_val[63:32];\n";
			} else {
				Out << "\telse if (read_data_asserted_lo) //to return data\n"<<
				"\t\tavs_s1_readdata = return_val;\n";
			}
		} 
		Out << "\telse\n"<<
		"\t\tavs_s1_readdata = 0;\n"<<
		"end\n\n";
	//if this is a sequential accelerator
	} else {
		//if this is not a void function
		if (!voidtype) {
			//print out always block to return data
			Out << "always @(*)\n"<<
			"begin\n";
			 if (return64) {
				Out << "\tif (read_data_asserted_lo) //to return data\n"<<
				"\t\tavs_s1_readdata = return_val[31:0];\n";
				Out << "\telse if (read_data_asserted_hi)\n"<<
				"\t\tavs_s1_readdata = return_val[63:32];\n";
			} else {
				Out << "\tif (read_data_asserted_lo) //to return data\n"<<
				"\t\tavs_s1_readdata = return_val;\n";
			}
			Out << "\telse\n"<<
			"\t\tavs_s1_readdata = 0;\n"<<
			"end\n\n";
		} 
	}


	return voidtype;
}


void VerilogWriter::printArbiterInstance(bool usesParallelAPI) {
	Out << "round_robin_arbiter arbiter(\n"<<
	"\t.rst_an(reset),\n"<<
	"\t.clk(clk),\n"<<
	"\t.req_in({flag_to_sdram_a";
	if (usesParallelAPI) {
		Out << "|api_address_a";
	}
	Out << ", flag_to_sdram_b";
	if (usesParallelAPI) {
		Out << "|api_address_b";
	}	
	Out << "}),\n"<<
	"\t.grant_comb({gnt_a, gnt_b}),\n"<<
	"\t.waitrequest(avm_ACCEL_waitrequest)\n"<<
	");\n\n";
}

void VerilogWriter::printMemoryInstance() {

    if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
	Out << "memory_controller memory_controller_inst (\n" <<
        "\t.clk( clk ),\n" <<
        "\t.memory_controller_enable_a( memory_controller_enable_a ),\n" <<
        "\t.memory_controller_enable_b( memory_controller_enable_b ),\n" <<
        "\t.memory_controller_address_a( memory_controller_address_a ),\n" <<
        "\t.memory_controller_address_b( memory_controller_address_b ),\n" <<
        "\t.memory_controller_write_enable_a( memory_controller_write_enable_a ),\n" <<                
        "\t.memory_controller_write_enable_b( memory_controller_write_enable_b ),\n" <<
        "\t.memory_controller_in_a( memory_controller_in_a ),\n"
        "\t.memory_controller_in_b( memory_controller_in_b ),\n";
	if (alloc->usesGenericRAMs()) {
		Out << "\t.memory_controller_size_a( memory_controller_size_a ),\n"<<
		"\t.memory_controller_size_b( memory_controller_size_b ),\n";
	}
	Out << "\t.memory_controller_waitrequest( memory_controller_waitrequest ),\n"<<
	"\t.memory_controller_out_reg_a( memory_controller_out_a ),\n" <<
	"\t.memory_controller_out_reg_b( memory_controller_out_b )\n" <<
	");\n\n";	
    } else {
	Out << "memory_controller memory_controller_inst (\n" <<
        "\t.clk( clk ),\n" <<
        "\t.memory_controller_enable_a( memory_controller_enable_a ),\n" <<
        "\t.memory_controller_enable_b( 1'b0 ),\n" <<
        "\t.memory_controller_address_a( memory_controller_address_a ),\n" <<
        "\t.memory_controller_address_b( {`MEMORY_CONTROLLER_ADDR_SIZE{1'b0}} ),\n" <<
        "\t.memory_controller_write_enable_a( memory_controller_write_enable_a ),\n" <<                
        "\t.memory_controller_write_enable_b( 1'b0 ),\n" <<
        "\t.memory_controller_in_a( memory_controller_in_a ),\n"
        "\t.memory_controller_in_b( {`MEMORY_CONTROLLER_DATA_SIZE{1'b0}} ),\n";
	if (alloc->usesGenericRAMs()) {
		Out << "\t.memory_controller_size_a( memory_controller_size_a ),\n"<<
		"\t.memory_controller_size_b( 2'b00 ),\n";
	}
	Out << "\t.memory_controller_waitrequest( memory_controller_waitrequest ),\n"<<
	"\t.memory_controller_out_reg_a( memory_controller_out_a ),\n" <<
	"\t.memory_controller_out_reg_b( )\n" <<
	");\n\n";	
    }
}

void VerilogWriter::printAccelInstance(const Function * F, int NumParams, bool voidtype) {

	//use this format for now until port name changes are fixed
	std::string funcName = F->getName().str();
	stripInvalidCharacters(funcName);
	Out << funcName << " " << funcName <<"_inst(\n" <<
	"\tclk,\n" <<
	"\t1'b0,//grounding clk2x signal used for multi-pumping\n" <<
	"\t1'b0,//grounding clk1x_follower signal used for multi-pumping\n" <<
	"\treset,\n" <<
	"\tstart_reg,\n" << //only use start_reg for stall mode since one cycle is required to send stall signal to processor at which time if accelerator accesses memory in the first cycle it will cause avalon did not heed error, in poll mode use start
	"\tfinish,\n";
	if (!voidtype) {
		Out << "\t" << "return_val_wire," << "\n";
	}

	if (NumParams > 0) { 
		int argIdx = 1;
        for (Function::const_arg_iterator i = F->arg_begin(), e = F->arg_end();
                i != e; ++i) {
	    	Out << "\tARG" << argIdx << ",\n";
			argIdx++;
		}
	}

	Out << "\tenable_a,\n" <<
	"\tmemory_address_a,\n" <<
	"\twrite_enable_a,\n" <<
	"\tdata_to_memory_a,\n";
	if (alloc->usesGenericRAMs()) {
		Out << "\tmemory_controller_size_a,\n";
	}
	Out << "\tdata_from_memory_a,\n";

	if (LEGUP_CONFIG->getParameterInt("DUAL_PORT_BINDING")) {
		Out << "\tenable_b,\n" <<
		"\tmemory_address_b,\n" <<
		"\twrite_enable_b,\n" <<
		"\tdata_to_memory_b,\n" <<
		"\tmemory_controller_size_b,\n" <<
		"\tdata_from_memory_b,\n";
	} else {
		Out << "\t, //grounding port b for hybrid case\n" <<
		"\t, //grounding port b for hybrid case\n" <<
		"\t, //grounding port b for hybrid case\n" <<
		"\t, //grounding port b for hybrid case\n";
		//if (alloc->usesGenericRAMs()) {
			Out << "\t, //grounding port b for hybrid case\n";
		//}
		Out << "\t{`MEMORY_CONTROLLER_DATA_SIZE{1'b0}}, //grounding port b for hybrid case\n";
	}
	Out << "\tmemory_controller_waitrequest\n" <<
	");\n\n";}

void VerilogWriter::printModelsimSignals(bool voidtype) {

	//modelsim display statement for time and return value
	Out << "always@(finish) begin\n"<<
	"\tif (finish == 1) begin\n"<<
	"\t\t$display(\"At t=%t clk=%b finish=%b";
	if (!voidtype) 
		Out << " return_val=%d\",";
	else
		Out << "\",";

	Out << " $time, clk, finish";
	if (!voidtype)
		Out << ", return_val_wire);\n";
	else
		Out << ");\n";
			
	Out << "\tend\n"<<
	"end\n\n";
	Out << "endmodule\n\n";
}

void VerilogWriter::printModuleHeader() {
    Out << "`timescale 1 ns / 1 ns\n";
	std::string moduleName = rtl->getName();
	stripInvalidCharacters(moduleName);
    //Out << "module " << rtl->getName() << "\n" <<
    Out << "module " << moduleName << "\n" <<
    "(" << "\n";

    for (RTLModule::const_signal_iterator i = rtl->port_begin(), e =
            rtl->port_end(); i != e; ++i) {
        Out << "\t" << (*i)->getName();
        if (i != rtl->port_end()-1) Out << ",";
        Out << "\n";
    }
    Out << ");" << "\n\n";

    for (RTLModule::const_signal_iterator i = rtl->param_begin(), e =
            rtl->param_end(); i != e; ++i) {
        printDeclaration(*i);
        Out << "\n";
    }

    if (rtl->param_begin() != rtl->param_end()) {
        Out << "\n";
    }

    for (RTLModule::const_signal_iterator i = rtl->port_begin(), e =
            rtl->port_end(); i != e; ++i) {
        printDeclaration(*i);
        Out << "\n";

    }

    for (RTLModule::const_signal_iterator i = rtl->signals_begin(), e =
            rtl->signals_end(); i != e; ++i) {
        printDeclaration(*i);
        Out << "\n";
    }
}

void VerilogWriter::printDeclaration(const RTLSignal *signal) {
    std::string type = signal->getType();
    if (!type.empty()) {
        if (type == "wire" &&
           (signal->getNumConditions() != 0 || signal->getNumDrivers() != 0)) {
            Out << "reg ";
        } else if (type == "output" && signal->getNumConditions() != 0) {
            Out << "output reg ";
        } else {
            Out << type << " ";
        }

    }
    Out << signal->getWidth().str() << " ";
    Out << signal->getName();
    if (!signal->getValue().empty()) {
        Out << " = ";
        printVerilogBitwidthPrefix(signal);
        Out << signal->getValue();
    }

    Out << ";";
}

void VerilogWriter::printRTL(const RTLModule *rtl) {

    this->rtl = rtl;

    printModuleHeader();

    for (RTLModule::const_module_iterator i = rtl->instances_begin(), e =
            rtl->instances_end(); i != e; ++i) {
        Out << "\n";
        printModuleInstance(Out, *i);
    }
    Out << "\n";

    // todo: local rams should be per function, ie:
    //for (RTLModule::const_ram_iterator i = rtl->ram_begin(), e =
    //        rtl->ram_end(); i != e; ++i) {
    if (LEGUP_CONFIG->getParameterInt("LOCAL_RAMS") && rtl->getName() == "main") {
        for (Allocation::const_ram_iterator i = alloc->ram_begin(), e = alloc->ram_end();
                i != e; ++i) {
            const RAM *R = *i;
            Out << "\n";
            printRamInstance(R);
        }
        Out << "\n";
    }

    Out << rtl->getPreamble() << "\n";

    // print unsynthesizable statements ($display, $finish, etc)
    printSignal(rtl->getUnsynthesizableSignal());

    // print signals
    for (RTLModule::const_signal_iterator i = rtl->signals_begin(), e =
            rtl->signals_end(); i != e; ++i) {
        printSignal(*i);
    }

    for (RTLModule::const_signal_iterator i = rtl->port_begin(), e = rtl->port_end();
            i != e; ++i) {
        printSignal(*i);
    }

    Out << rtl->getBody() << "\n";

    Out << "endmodule " << "\n";

}

void VerilogWriter::printModuleInstance(raw_ostream &Out, const RTLModule *mod) {
    Out << mod->getBody() << "\n";
    Out << mod->getName() << " " << mod->getInstName() << " (" << "\n";
    for (RTLModule::const_signal_iterator i = mod->port_begin(), e =
            mod->port_end(); i != e; ++i) {

        const RTLSignal *s = *i;
        unsigned sigWidth = s->getWidth().numBits(rtl,alloc);
        const RTLSignal *d = s->getDriver(0);
        assert(d && "Connection doesn't exist!\n");
        Out << "\t." << s->getName() << " (";
        printValue(d,sigWidth,true);
        Out << ")";
        if (i != mod->port_end()-1) {
            Out << ",";
        }
        Out << "\n";
    }
    Out << ");" << "\n\n";

    for (RTLModule::const_signal_iterator i = mod->param_begin(), e =
            mod->param_end(); i != e; ++i) {
        if (i == mod->param_begin()) {
            Out << "defparam" << "\n\t";
        } else {
            Out << ",\n\t";
        }
        Out << mod->getInstName() << "." << (*i)->getName() << " = " <<
            (*i)->getValue();
        if (i == mod->param_end()-1) {
            Out << ";\n";
        }
    }

}

// recursively check if a signal is driven by a constant ie.
// a = 0;
// note, this would also be a constant:
// main_legup_memset_4_exit_7 = `TAG_main_0_previous_a + 4 * 32'd14;
bool VerilogWriter::isConst(const RTLSignal *sig) {
    if (sig->isConst()) return true;
    if (sig->isOp()) {
        const RTLOp* op = (const RTLOp*)sig;
        for (unsigned i = 0; i < op->getNumOperands(); i++) {
            if (!isConst(op->getOperand(i))) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}

// need this otherwise always block doesn't always trigger ie.
// always(*)
//    a = 0;
// will never trigger and signal 'a' will always be 'X'
void VerilogWriter::printAlwaysTrigger(const RTLSignal *signal, const RTLSignal
        *driver) {
    if (isConst(driver)) {
        Out << "if (reset) begin " << signal->getName()
            << " = 0; end\n";
    }
}

void VerilogWriter::printConditions(const RTLSignal *signal, std::string
        assignOp) {
    unsigned numConditions = signal->getNumConditions();
    assert(numConditions > 0);
    unsigned sigWidth = signal->getWidth().numBits(rtl,alloc);
    bool reg = signal->isReg();
    for (unsigned i = 0; i < numConditions; ++i) {
        const RTLSignal *driver = signal->getDriver(i);
        const RTLSignal *condition = signal->getCondition(i);
        assert(driver);
        const Instruction *I = signal->getInst(i);

        printComments(I);

        // don't "else" if the signal is not synthesizable, if it is a reg or
        // if it has a default driver
        bool no_else = (signal == rtl->getUnsynthesizableSignal()) || reg ||
            signal->getDefaultDriver();

        if (no_else) {
            Out << "if (";
            printValue(condition);
            Out << ")\n";
        } else { // add "else"s
            if (numConditions > 1) {
                if (numConditions > 1 && i == numConditions-1) {
                    Out << "else ";
                    Out << "/* if (";
                    printValue(condition);
                    Out << ") */\n";
                } else {
                    if (i > 0) {
                        Out << "else if (";
                    } else {
                        Out << "if (";
                    }
                    printValue(condition);
                    Out << ")\n";
                }
            } else {
                printAlwaysTrigger(signal, driver);
            }
        }

        Out << "begin\n";
        if (signal != rtl->getUnsynthesizableSignal()) {
            Out << signal->getName() << " " << assignOp << " ";
        }
        printValue(driver,sigWidth);
        Out << ";\n";

        // debugging
        // assert that we never assign an X to a variable
        // Note: need === instead of ==
        // xor (^) catches cases where the X is only in part of the signal
        if (reg) {
            Out << "if (^reset !== 1'bX && ^(";
            printValue(driver,sigWidth);
            Out << ") === 1'bX) begin " <<
                "$display (\"ERROR: Right hand side is 'X'. Assigned to " <<
                signal->getName() << "\");" << " $finish; end\n";
        }

        Out << "end\n";
    }
}

void VerilogWriter::printSignal(const RTLSignal *signal) {
    if (signal->getNumDrivers() == 0) return;

    bool reg = signal->isReg();
    unsigned sigWidth = signal->getWidth().numBits(rtl,alloc);

    // use non-blocking assignment for  logic
    std::string assignOp = "<=";
    if (signal == rtl->getUnsynthesizableSignal()) {
        Out << "/* Unsynthesizable Statements */\n";
        Out << "always @(posedge clk) begin\n";
    } else {
        if (reg) {
            Out << "always @(posedge clk) begin\n";
        } else {
            Out << "always @(*) begin\n";
            // use blocking assignment for combinational logic
            assignOp = "=";
            const RTLSignal *defaultDriver = signal->getDefaultDriver();
            if (defaultDriver) {
                // ie. memory_controller_enable as a default of 0
                Out << signal->getName() << " " << assignOp << " ";
                printValue(defaultDriver,sigWidth);
                Out << ";\n";
            }
        }
    }


    // there is only a single driver
    if (signal->getNumConditions() == 0) {

        printComments(signal->getInst(0));

        const RTLSignal *driver = signal->getDriver(0);
        assert(driver);
        Out << signal->getName() << " " << assignOp << " ";
        printValue(driver,sigWidth);
        Out << ";\n";
        printAlwaysTrigger(signal, driver);
    } else {
        printConditions(signal, assignOp);
    }

    Out << "end\n";
}
void VerilogWriter::printComments(const Instruction *I) {
    if (!I) return;
    //static std::map<const Instruction *I, std::string> cache;
    const BasicBlock *b = I->getParent();
    if (b) {
        Out << "/* " << b->getParent()->getName() << ": " <<
            getLabel(b) << "*/\n";
    }
    Out << "/* " << getValueStr(I) << "*/\n";
}

void VerilogWriter::printVerilogOpcode(RTLOp::Opcode opcode) {
    switch (opcode) {
        case RTLOp::Add: Out << " + ";   break;
        case RTLOp::Sub: Out << " - ";   break;
        case RTLOp::Mul: Out << " * ";   break;
        case RTLOp::Rem: Out << " % ";   break;
        case RTLOp::Div: Out << " / ";   break;
        case RTLOp::And: Out << " & ";   break;
        case RTLOp::Or:  Out << " | ";   break;
        case RTLOp::Xor: Out << " ^ ";   break;
        case RTLOp::Shl: Out << " <<< "; break;
        case RTLOp::Shr: Out << " >>> "; break;
        case RTLOp::EQ:  Out << " == ";  break;
        case RTLOp::NE:  Out << " != ";  break;
        case RTLOp::LT:  Out << " < ";   break;
        case RTLOp::LE:  Out << " <= ";  break;
        case RTLOp::GT:  Out << " > ";   break;
        case RTLOp::GE:  Out << " >= ";  break;
        /*case RTLOp::OEQ:  Out << " == ";  break;
        case RTLOp::UNE:  Out << " != ";  break;
        case RTLOp::OLT:  Out << " < ";   break;
        case RTLOp::OLE:  Out << " <= ";  break;
        case RTLOp::OGT:  Out << " > ";   break;
        case RTLOp::OGE:  Out << " >= ";  break;*/
        default: llvm_unreachable("Invalid operator type!");
    }
}

// print bitwidth prefix. ie. 6'd
void VerilogWriter::printVerilogBitwidthPrefix(const RTLSignal *sig) {
    // add bitwidth
    if (isNumeric(sig->getValue())) {
        rtl->verifyBitwidth(sig, alloc);
        unsigned bits = sig->getWidth().numBits(rtl, alloc);
        // numbers are 32 bits wide by default
        if (bits != 32) Out << bits << "'d";
    }
}

// printValue with optional w and zeroExtend parameters
// printValue(sig) calls printValue(sig,0,false)
// printValue(sig,w) calls printvalue(sig,w,false)
// w is the width of the driven signal.  This is useful to figure out how much we need to sign or
// zero extend the driver.  
// zeroExtend is a flag that says whether we need to manually zeroExtend signals.
void VerilogWriter::printValue(const RTLSignal *sig, unsigned w, bool zeroExtend) {
//    unsigned w2 = sig->getNativeWidth().numBits(rtl,alloc); 
//    if(w2>=2) {
//        w=w2;
        //w = min(w,w2);
/*        if(w>w2 && sig->getSigned()) {
            errs() << "w: "<<utostr(w)<<" w2: "<<utostr(w2)
                   << " for signal: "<<sig->getName()<<sig->getValue()<<"\n";
        }*/
//    }
    
    assert(sig && "sig is NULL");
    if (sig->isOp()) {
        printVerilogOperator((const RTLOp*)sig,w);
    } else if (sig->getType() == "parameter") {
        Out << sig->getName();
    } else {
        if (sig->getValue().empty()) {
            bool USE_LSB = LEGUP_CONFIG->getParameterInt("MB_MINIMIZE_LSB");
            std::string hi = sig->getWidth().getHi();
            std::string lo = sig->getWidth().getLo();
            unsigned extendFrom=0,LSB=0;
            if(USE_LSB) {
                if(hi!="") stringstream(hi) >> extendFrom;
                stringstream(lo) >> LSB;
            }
            else extendFrom = sig->getWidth().numBits(rtl,alloc)-1;
            bool isSigned = sig->getSigned();
            // normal variable ie. cur_state
            unsigned minW=extendFrom+1;
            if(w>0 && (LSB>0 || (minW < w))) {                
                //if minW is 1, signal needs to printed something like this: "{32{sig_name}}" if the
                //signal is signed
                if(minW==1) {
                    if(isSigned) Out << "{" << utostr(w) << "{" << sig->getName() << "}}";
                    else if(zeroExtend) 
                        Out << "{" << utostr(w-1) << "'d0," << sig->getName() << "}";
                    else Out << sig->getName();
                }
                else {                    
                    //Opening bracket needed in all cases
                    Out << "{";
                    //The first part of a signal with extendFrom==19 should be printed like this:
                    //"{12{sig_name[19]}},", if the signal is signed
                    if(minW < w) {
                        if(isSigned) 
                            Out << "{" << utostr(w-minW) << "{" << sig->getName() << "["
                                        << utostr(extendFrom) << "]" << "}},";
                        else if(zeroExtend)
                            Out << utostr(w-minW) << "'d0,";
                    }
                    //The second part of the same signal can be like this if LSB==0:
                    //sig_name
                    if(LSB==0) Out << sig->getName();
                    //if LSB>0, the second part of the signal should be like this:
                    //sig_name[19:LSB]
                    //if LSB>0, the third part of the signal should be zeroes
                    else {
                        Out << sig->getName() << "[" << utostr(extendFrom) << ":" 
                            << utostr(LSB) << "],"<<utostr(LSB)<<"'d0";
                    }
                    Out << "}";
                }
            }

            else {
                Out << sig->getName();
            }
        } else {
            printVerilogBitwidthPrefix(sig);
            Out << sig->getValue();
        }
    }
    
}

void VerilogWriter::printDisplay(const RTLOp *op) {
    assert(op->getOpcode() == RTLOp::Write
            || op->getOpcode() == RTLOp::Display);
    if (LEGUP_CONFIG->getParameterInt("PRINTF_CYCLES")) {
        Out << "$write(\"Cycle: %d Time: %d    \", ($time-50)/20, $time);\n";
    }
    if (op->getOpcode() == RTLOp::Write) {
        Out << "$write(";
    } else {
        Out << "$display(";
    }
    for (unsigned i = 0; i < op->getNumOperands(); i++) {
        Out << ((i > 0) ? ", " : "");
        if(op->getOpcode() == RTLOp::Write && i==1)
            printValue(op->getOperand(i),
                       op->getOperand(i)->getNativeWidth().numBits(rtl,alloc));
        else
            printValue(op->getOperand(i));
    }
    Out << ")";

    if (op->getNumOperands() > 1) {
        Out << ";\n";
        Out << "// to fix quartus warning\n";
        // avoid getting a warning from quartus that we
        // never read the value being printed
        for (unsigned i = 1; i < op->getNumOperands(); i++) {
            Out << "if (^reset !== 1'bX && ^(";
            printValue(op->getOperand(i));
            Out << ") === 1'bX) " <<
                "finish <= 0";
            if (i != op->getNumOperands()-1) Out << ";\n";
        }
    }
}
void VerilogWriter::printVerilogOperator(const RTLOp *op, unsigned w) {
    assert(op);

    if (op->getOpcode() == RTLOp::Finish) {
        Out << "$finish";
    } else if (op->getOpcode() == RTLOp::Write
            || op->getOpcode() == RTLOp::Display) {
        printDisplay(op);
    } else {
        switch (op->getNumOperands()) {
            case 3:
                assert(op->getOpcode() == RTLOp::Sel);
                Out << "(";
                printValue(op->getOperand(0),w);
                Out << " ? ";
                printValue(op->getOperand(1),w);
                Out << " : ";
                printValue(op->getOperand(2),w);
                Out << ")";
                break;
            case 2:
                Out << "(";
                printValue(op->getOperand(0),w);
                printVerilogOpcode(op->getOpcode());
                printValue(op->getOperand(1),w);
                Out << ")";
                break;
            case 1:
                if (op->getOpcode() == RTLOp::Not) {
                    Out << "~(";
                    printValue(op->getOperand(0),w);
                    Out << ")";
                } else if (op->getOpcode() == RTLOp::SExt) {
                    Out << "$signed(";
                    const RTLSignal *op0 = op->getOperand(0);
                    //The left most bit of the signal will count as a sign bit.
                    //If this is an unsigned signal, we need to pad it with a zero
                    //Typically, when setting the zeroExtend flag to true, this will happen
                    //but with a signed comparison, since the output width is one, printValue
                    //won't know by how much to zeroExtend, so we have to set w manually to be
                    //one more than signal width 
                    if(!op0->getSigned() &&
                       (op0->getNativeWidth().numBits(rtl,alloc) >
                       op0->getWidth().numBits(rtl,alloc))) {
//                        if(w<=op0->getWidth().numBits(rtl,alloc)) w=op0->getWidth().numBits(rtl,alloc)+1;
                        printValue(op->getOperand(0),op0->getNativeWidth().numBits(rtl,alloc),true);
                    }
                    else printValue(op->getOperand(0),w);
                    Out << ")";
                } else if (op->getOpcode() == RTLOp::ZExt) {
                    printValue(op->getOperand(0),w);
                } else {
                    assert(op->getOpcode() == RTLOp::Trunc);
                    // ie. memory_controller_out[31:0]
                    printValue(op->getOperand(0),w);
                    // don't truncate a constant
                    if (!op->getOperand(0)->isConst()) {
                        Out << op->getWidth().str();
                    }
                }
                break;
            default:
                llvm_unreachable("Invalid RTLOp!");
        }
    }
}

} // End legup namespace

